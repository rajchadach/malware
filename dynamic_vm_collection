from modules import workstationVm
import os, sys, time, struct
import re
from modules import w10pf_parse
from modules import eventLogs
from modules import memoryExtraction
import datetime
import glob
from regipy.registry import RegistryHive
import csv
import zipfile
import subprocess
import zugbruecke as ctypes  
import shutil
import pathlib
from regipy.exceptions import RegistryKeyNotFoundException, NoRegistryValuesException
from regipy.plugins.system.external.ShimCacheParser import get_shimcache_entries
from regipy.plugins.amcache import amcache
from regipy.utils import convert_wintime, convert_filetime
from inflection import underscore
from regipy.plugins.software import persistence
from regipy.utils import get_subkey_values_from_list
from regipy.plugins.ntuser import persistence
from regipy.plugins.ntuser import user_assist
import codecs
from construct import *
import Static_Main
import sqlite3 as lite
from os.path import expanduser
import pandas as pd
import json
import LnkParse3
from olefile import olefile
from modules import JumpListParser
import binascii
import numpy as np
from countdown import countdown
from ast import literal_eval

# ref: https://janakiev.com/blog/time-and-timezones-in-python/
# ref: https://docs.vmware.com/en/VMware-Fusion/10.0/com.vmware.fusion.using.doc/GUID-FF306A59-080E-497E-857D-F45125927FB3.html
print(
    "**********************************************Dynamic Analysis Features******************************************")
print(
    "*****************************************************************************************************************")
############################################VM Malware (Windows 10)#####################################################
################################################Running Malware#########################################################
# ref: https://github.com/rapid7/vm-automation/blob/master/vm_automation/workstationVm.py
# ref: https://github.com/mechboxes/mech/blob/master/mech/vmrun.py
# ref: https://github.com/PoorBillionaire/Windows-Prefetch-Parser

class PEDynamic(object):

    def __init__(self, malware_path):
        self.malware_path = malware_path
        self.procList = []
        self.count = 1
        self.tempResult = []
        self.pid = []
        self.vmMalware = workstationVm.workstationServer("130.217.181.48") #130.217.181.48

    def noribenExtraction(self):
        extractFolder = "/Users/koyko/Documents/Noriben"
        if os.path.exists("/Users/koyko/Documents/Result_NoribenReport"):
            try:
                with zipfile.ZipFile(pathlib.Path("/Users/koyko/Documents/Result_NoribenReport"), mode='r') as zipObj:
                    listOfFileNames = zipObj.namelist()
                    for fileName in listOfFileNames:
                        if fileName.endswith('.csv'):
                            zipObj.extract(fileName, extractFolder)
            except zipfile.BadZipfile:
                print("Error opened file")
            f = open("/Users/koyko/Documents/outNoriben.csv", "w")
            csvWriter = csv.DictWriter(f, fieldnames=["Time of Day", "Process Name", "PID", "Operation", "Path",
                                                  "Result", "Detail"])
            csvWriter.writeheader()
            f.close()
        if os.path.exists(extractFolder):
            for zipF in os.scandir(extractFolder):
                for sf in os.scandir(zipF):
                    if os.stat(pathlib.Path(sf)).st_size > 0:
                        df = pd.read_csv(pathlib.Path(sf))
                        for index, row in df.iterrows():
                            try:
                                if re.search(r'(test.exe|winword.exe|test.msi)', str(row["Process Name"]).lower()) or str(self.malware_path).split("/")[-1].split(".")[0].lower()[0:3] in str(row["Process Name"]).lower():
                                    with open("/Users/koyko/Documents/outNoriben.csv", "a") as nori:
                                        csvWriter = csv.writer(nori, delimiter=',', quoting=csv.QUOTE_MINIMAL)
                                        csvWriter.writerow(row)  # remain preprocess only relevant data
                            except:
                                pass
        else:
            pass
        if os.path.exists("/Users/koyko/Documents/outNoriben.csv") and os.stat('/Users/koyko/Documents/outNoriben.csv').st_size > 59:
            df = pd.read_csv("/Users/koyko/Documents/outNoriben.csv")
            if not os.path.exists('/Users/koyko/Documents/prefetch.csv'):
                df_p = pd.DataFrame([{"Real Filename": str(self.malware_path).split("/")[-1]}])
                df_p.to_csv('/Users/koyko/Documents/prefetch.csv', index=False)
            df2 = pd.read_csv('/Users/koyko/Documents/prefetch.csv')
            df2["PID_Noriben"] = df2.apply(lambda df2: df["PID"].drop_duplicates().to_list(), axis=1)
            df2["Operation"] = df2.apply(lambda df2: df["Operation"].drop_duplicates().to_list(), axis=1)
            df2.to_csv('/Users/koyko/Documents/prefetch.csv', index=False)
            nori_pid = df["PID"].drop_duplicates().to_list()
            if len(self.pid) != 0:
                for ni in nori_pid:
                    if str(ni) not in self.pid:
                        self.pid.append(str(ni))
            else:
                for ni in nori_pid:
                    self.pid.append(str(ni))
            print(self.pid)
        else:
            pass

    def disableRTP(self):
        disableRTP = ["cmd.exe",
            "powershell.exe -Command Start-Process cmd \"/c powershell Start-Process Powershell -ArgumentList 'Set-MpPreference -DisableRealtimeMonitoring 1'\""]
        self.vmMalware.runCmdOnGuest(disableRTP)
        time.sleep(15)
        self.runMalware()

    def runMalware(self):
        # print(str(vmMalware.queryVmIp()))
        # vmMalware.waitForVmsToBoot()
        pathlib.Path("/Users/koyko/Downloads/Malware_Test").mkdir(exist_ok=True)  # create malware sample directory
        shutil.move(self.malware_path, "/Users/koyko/Downloads/Malware_Test", copy_function="copystat")
        print(f"{self.count} file copied successfully.")
        self.vmMalware.uploadFileToGuest("/Users/koyko/Downloads/Malware_Test", "C:\\Users\\koyko\\Desktop") #upload in folder
        print("Successfully Uploaded Application")
        if str(self.malware_path.split("/")[-1]).endswith((".doc", ".docx")):
            #self.vmMalware.uploadFileToGuest("/Users/koyko/Downloads/WordPS", "C:\\Users\\koyko\\Desktop")
            #print("Successfully PS script") 
            self.vmMalware.renameFileInGuest("C:\\Users\\koyko\\Desktop\\"+ self.malware_path.split("/")[-1], "C:\\Users\\koyko\\Desktop\\test.doc")
            execMalware = ["cmd.exe", "powershell.exe -Command Start-Process cmd \"/c start winword /q /f C:\\Users\\koyko\\Desktop\\test.doc\""]
            self.vmMalware.runCmdOnGuest(execMalware)
        elif ".msi" in self.malware_path.split("/")[-1]:
            self.vmMalware.renameFileInGuest("C:\\Users\\koyko\\Desktop\\" + self.malware_path.split("/")[-1],
                                             "C:\\Users\\koyko\\Desktop\\test.msi")
            execMalware = ["cmd.exe", "powershell.exe -Command Start-Process cmd \"/c msiexec /i C:\\Users\\koyko\\Desktop\\test.msi /qn /norestart\""] #/norestart /qn
            self.vmMalware.runCmdOnGuest(execMalware)

        elif ".AppxBundle" in self.malware_path.split("/")[-1]:
            self.vmMalware.renameFileInGuest("C:\\Users\\koyko\\Desktop\\" + self.malware_path.split("/")[-1],
                                             "C:\\Users\\koyko\\Desktop\\test.AppxBundle")
            execMalware = ["cmd.exe",
                           "powershell.exe -Command Start-Process cmd \"/c start powershell Add-AppxPackage -Path C:\\Users\\koyko\\Desktop\\test.AppxBundle && C:\\Python3.8\\python.exe C:\\Users\\koyko\\Desktop\\Noriben.py -d -t 300 --output G:\\Noriben_Logs\""]
            self.vmMalware.runCmdOnGuest(execMalware)
        elif ".appx" in self.malware_path.split("/")[-1]:
            self.vmMalware.renameFileInGuest("C:\\Users\\koyko\\Desktop\\" + self.malware_path.split("/")[-1],
                                             "C:\\Users\\koyko\\Desktop\\test.appx")
            execMalware = ["cmd.exe",
                           "powershell.exe -Command Start-Process cmd \"/c start powershell Add-AppxPackage -Path C:\\Users\\koyko\\Desktop\\test.appx && C:\\Python3.8\\python.exe C:\\Users\\koyko\\Desktop\\Noriben.py -d -t 300 --output G:\\Noriben_Logs\""]
            self.vmMalware.runCmdOnGuest(execMalware)
        else: 
            self.vmMalware.renameFileInGuest("C:\\Users\\koyko\\Desktop\\" + self.malware_path.split("/")[-1],
                                                     "C:\\Users\\koyko\\Desktop\\test.exe")
            execMalware = ["cmd.exe","powershell.exe -Command Start-Process cmd \"/c C:\\Python3.8\\python.exe C:\\Users\\koyko\\Desktop\\Noriben.py -d -t 300 --cmd C:\\Users\\koyko\\Desktop\\test.exe --output G:\\Noriben_Logs\""]
            self.vmMalware.runCmdOnGuest(execMalware)
        execNoriben = ["cmd.exe",
            "powershell.exe -Command Start-Process cmd \"/c C:\\Python3.8\\python.exe C:\\Users\\koyko\\Desktop\\Noriben.py -d -t 300 --output G:\\Noriben_Logs\""]
        self.vmMalware.runCmdOnGuest(execNoriben)

        print("Completely Execute Application")
        self.vmMalware.getFileFromGuest("G:\\DumpFiles", "/Users/koyko/Documents/Result")
        print("Finishing Dump file")
        self.procList = str(self.vmMalware.updateProcList(), encoding="utf-8").splitlines()
        procDict = {}
        for proc in self.procList:
            try:
                procDict.update({"Pid": proc.split(",")[0].split("=")[1], "Owner": proc.split(",")[1].split("=")[1],
                                 "CMD": proc.split(",")[2].split("=")[1]})
                df = pd.DataFrame([procDict])
                df.to_csv("/Users/koyko/Documents/procList.csv", header=False, index=False, mode="a")
            except:
                pass
        if os.path.exists("/Users/koyko/Documents/procList.csv"):
            df_pid = pd.read_csv("/Users/koyko/Documents/procList.csv")
            mal_n = str(self.malware_path).split("/")[-1]
            if mal_n.endswith(".exe") or mal_n.endswith(".msi"):
                mal_n = mal_n.split(".")[0].lower()
                mal_n = re.sub(r"[\s+_]", "", mal_n)
            else:
                mal_n = mal_n.lower()
            for pp in df_pid.astype('str').values:
                if re.findall(r'(^test.exe|^winword.exe|^notepad\+\+.exe)', str(pp[2]).lower()): #|wermgr.exe
                    self.pid.append(str(pp[0])) #.split("'")[1]
                    pass
                else:
                    count = 0
                    proc_n = str(pp[2]).split(".")[0].lower()
                    if not re.findall(r'^(svchost.exe|explorer.exe|fontdrvhost.exe|WUDFHost.exe|SettingSyncHost.exe|searchindexer.exe|sgrmbroker.exe|runtimebroker.exe|sedlauncher.exe|trustedinstaller.exe|tiworker.exe|wininit.exe|SecurityHealthService.exe|VGAuthService.exe|vm3dservice.exe|services.exe|winlogon.exe|Windows10Upgrade.exe|backgroundTaskHost.exe|WindowsUpdateBox.exe)', str(pp[2]).lower()):
                        for i in range(len(mal_n)):
                            for j in range(len(proc_n)):
                                if mal_n[i:i + 3] == proc_n[j:j + 3]:
                                    count += 1
                    if count >= 2:
                        self.pid.append(str(pp[0]))  # .split("'")[1]
            print(self.pid)
        else:
            pass
        noribenOutput = ["cmd.exe", "powershell.exe -Command Start-Process cmd \"/c C:\\Users\\koyko\\Downloads\\zip.exe -r G:\\Noriben_report.zip G:\\Noriben_Logs\""]
        self.vmMalware.runCmdOnGuest(noribenOutput)
        print("Compress Record Application Result")
        self.vmMalware.getFileFromGuest("G:\\Noriben_report.zip", "/Users/koyko/Documents/Result")
        print("Finishing download compressed Noriben Reports")

        ###################################################Data Extraction######################################################

        self.vmMalware.getFileFromGuest("C:\\Windows\\Prefetch", "/Users/koyko/Documents/Result")
        print("Finishing download prefetch folder")
        self.vmMalware.getFileFromGuest("C:\\Windows\\System32\\winevt\\Logs", "/Users/koyko/Documents/Result")
        print("Finishing download event logs")
        self.vmMalware.getFileFromGuest("G:\\Temp", "/Users/koyko/Documents/Result")
        print("Finishing download user temp")
        self.vmMalware.getFileFromGuest("C:\\Windows\\Temp", "/Users/koyko/Documents/Result")
        print("Finishing download system temp")

        regList = ["cmd.exe",
                           "powershell.exe -Command ""Start-Process cmd \"/c reg save HKLM\SOFTWARE G:\\regback\\software && reg save HKLM\SYSTEM G:\\regback\\system && reg save HKLM\SAM G:\\regback\\sam && reg save HKCU G:\\regback\\NTUSER.DAT && reg save HKCU\Software\Classes G:\\regback\\USRCLASS.DAT\""]  # powershell.exe -Command "Start-Process cmd \"/c reg save HKLM\SAM C:\sam \" -Verb RunAs"
        self.vmMalware.runCmdOnGuest(regList)
        self.vmMalware.getFileFromGuest("G:\\regback", "/Users/koyko/Documents/Result")
        print("Finishing download registry")

        activityCache = ["cmd.exe",
                                     "powershell.exe -Command ""Start-Process cmd \"/c xcopy /H C:\\Users\\koyko\\AppData\\Local\\ConnectedDevicesPlatform\\626ae0e179f145e1 G:\\ActivityCache\""]  # L.Koyko
        self.vmMalware.runCmdOnGuest(activityCache)
        self.vmMalware.getFileFromGuest("G:\\ActivityCache", "/Users/koyko/Documents/Result")
        print("Finishing download activity cache")
        self.vmMalware.getFileFromGuest("C:\\Users\\koyko\\AppData\\Roaming\\Microsoft\\Windows\\Recent",
                                                    "/Users/koyko/Documents/Result")
        print("Finishing download Jump List")
        self.vmMalware.getFileFromGuest(
                        "C:\\Users\\koyko\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs",
                        "/Users/koyko/Documents/Result")
        print("Finishing download lnk files")

        time.sleep(5)
        self.vmMalware.getFileFromGuest("C:\\ProgramData\\Microsoft\\Windows Defender\\Support",
                                                                "/Users/koyko/Documents/Result")
        print("Finishing download Threat History")

        self.checkProcessinTemp()
        self.analyzePrefetch()
        self.analyzeEVTMem()
        self.analyzeArtifacts()
        time.sleep(2)
        self.vmMalware.deleteSnapshot("malware-test")
        print("Delete app snapshot")
        self.vmMalware.revertToSnapshot("Snapshot-Clean")
        print("Revert to clean state")
        shutil.rmtree("/Users/koyko/Downloads/Malware_Test", ignore_errors=True)  # remove malware sample directory

    ####################################################Data Analysis#######################################################
    def checkProcessinTemp(self):
        for files_path in os.scandir("/Users/koyko/Documents"):
            if files_path.name.endswith("_UsrTemp") or files_path.name.endswith("_SysTemp") or files_path.name.endswith("_DumpDMP"):
                print("EXE in temp folder")
                for sub in os.scandir(files_path.path):
                    if sub.is_dir():
                        if sub.name == "Silent Process Exit":
                            for file in os.scandir(sub.path):
                                if file.is_dir():
                                    self.pid.append(str(file.name).split("-", 1)[1].split("-")[1].strip(")"))
                        if "test.exe" in sub.name:
                            self.pid.append(str(sub.name).split("-", 1)[1].split("-")[1].strip(")"))
                try:
                    df_pid = pd.read_csv("/Users/koyko/Documents/procList.csv")
                    if len(os.listdir(files_path)) != 0:
                        for r, d, f in os.walk(files_path):
                            for file in f:
                                for pp in df_pid.astype('str').values:
                                    if str(file).lower() == str(pp[2]).lower() and str(file).lower() != "svchost.exe" and str(file).lower() != "services.exe":
                                        self.pid.append(str(pp[0]))
                        #self.pid = list(set([c for c in self.pid if self.pid.count(c) > 1])
                except:
                    pass  # remain preprocess only relev
                print(self.pid)

    def getSystemHive(self, files_path):
        regSYS = RegistryHive(files_path)
        temp = []
        appcompat = []
        try:
            for shim_entry in regSYS.get_control_sets(
                    r'Control\Session Manager'):  # shimcache/appcompat in \\CurrentControlSet\\Control\\SessionManager\\AppCompatCache
                shimcache = regSYS.get_key(shim_entry).get_key('AppCompatCache').get_value('AppCompatCache')
                if shimcache:
                    print("Shimcache")
                    for value in get_shimcache_entries(shimcache, as_json=True):
                        temp.append(value)
                    for item in temp:
                        if re.findall(r'(test.exe|winword.exe|test.msi)', item["path"]): # last_mod_date and path
                            appcompat.append(item)
                    df = pd.DataFrame(appcompat)
                    df.to_csv("/Users/koyko/Documents/appcompat.csv", index=False, mode="a")
            print("BAM")
            for serv_entry in regSYS.get_control_sets(r'Services\bam'):  # bam \\ControlSet001\\Services\\bam\\UserSettings\\{SID}
                pd.read_json(json.dumps(regSYS.get_key(serv_entry).get_values(as_json=True))).to_csv('/Users/koyko/Documents/bam.csv', index=False,
                  mode="a")
        except:
            pass

    def getSoftwareHive(self, files_path):
        regSW = RegistryHive(files_path)
        uninstall_sk = regSW.get_key(r'\Microsoft\Windows\CurrentVersion\Uninstall')
        install_entry = []
        for installed_program in uninstall_sk.iter_subkeys():
            values = {underscore(x.name): x.value for x in
                      installed_program.iter_values(as_json=True)} if installed_program.values_count else {}
            install_entry.append({
                'service_name': installed_program.name,
                'timestamp': convert_wintime(installed_program.header.last_modified, as_json=True),
                'registry_path': "\\Microsoft\\Windows\\CurrentVersion\\Uninstall", **values})
        df = pd.DataFrame(install_entry)
        df.to_csv("/Users/koyko/Documents/installP.csv", index=False, mode="a")
        profile_entry = []
        profile_subkey = regSW.get_key(r"\Microsoft\Windows NT\CurrentVersion\ProfileList")
        for profile in profile_subkey.iter_subkeys():
            profile_entry.append({
                'last_write': convert_wintime(profile.header.last_modified, as_json=True),
                'path': profile.get_value('ProfileImagePath'),
                'flags': profile.get_value('Flags'),
                'full_profile': profile.get_value('FullProfile'),
                'state': profile.get_value('State'),
                'sid': profile.name,
                'load_time': convert_filetime(profile.get_value('ProfileLoadTimeLow'),
                                              profile.get_value('ProfileLoadTimeHigh')),
                'local_load_time': convert_filetime(profile.get_value('LocalProfileLoadTimeLow'),
                                                    profile.get_value('LocalProfileLoadTimeHigh'))})
        df1 = pd.DataFrame(profile_entry)
        df1.to_csv("/Users/koyko/Documents/profile.csv", header=False, index=False, mode="a")
        uac_entry = {}
        uac_subkey = regSW.get_key(r'\Microsoft\Windows\CurrentVersion\Policies\System')
        uac_entry.update({
            'last_write': convert_wintime(uac_subkey.header.last_modified, as_json=True),
            'enable_limited_user_accounts': uac_subkey.get_value('EnableLUA', as_json=True),
            'enable_virtualization': uac_subkey.get_value('EnableVirtualization', as_json=True),
            'filter_admin_token': uac_subkey.get_value('FilterAdministratorToken', as_json=True),
            'consent_prompt_admin': uac_subkey.get_value('ConsentPromptBehaviorAdmin', as_json=True),
            'consent_prompt_user': uac_subkey.get_value('ConsentPromptBehaviorUser', as_json=True)})
        df2 = pd.DataFrame.from_dict([uac_entry])
        df2.to_csv("/Users/koyko/Documents/uac.csv", index=False, mode="a")
        explorer = []
        recent_sk = regSW.get_key(
            r'\Microsoft\Windows\CurrentVersion')  # ShellIconOverlayIdentifiers\*, #HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Explorer\ShellIconOverlayIdentifiers\*
        for recent in recent_sk.iter_subkeys():
            #print(recent.get_values(as_json=True))
            explorer.append({
                'AppName': recent.name,
                'Value': recent.get_value('value'),
                'Value_type': profile.get_value('value_type'),
                'Is_corrupted': profile.get_value('is_corrupted')})
        df3 = pd.DataFrame(explorer)
        df3.to_csv("/Users/koyko/Documents/currentV.csv", index=False, mode="a")

    def getNTUserHive(self, files_path):
        #log1 = open('/mnt/tmp/Users/jcloudy/ntuser.dat.LOG1', 'rb')
        #log2 = open('/mnt/tmp/Users/jcloudy/ntuser.dat.LOG2', 'rb')
        regNT = RegistryHive(files_path)
        nt_persistence = get_subkey_values_from_list(regNT, persistence.PERSISTENCE_ENTRIES, as_json=True)
        df = pd.DataFrame(nt_persistence)
        df.to_csv("/Users/koyko/Documents/nt_persistence.csv", index=False, mode="a")
        uninstall_sk = regNT.get_key(r'\Software\Microsoft\Windows\CurrentVersion\Uninstall')
        uninstall_entry = []
        for installed_program in uninstall_sk.iter_subkeys():
            values = {underscore(x.name): x.value for x in
                      installed_program.iter_values(as_json=True)} if installed_program.values_count else {}
            uninstall_entry.append({
                'service_name': installed_program.name,
                'timestamp': convert_wintime(installed_program.header.last_modified, as_json=True),
                'registry_path': "\\Microsoft\\Windows\\CurrentVersion\\Uninstall", **values})
        df1 = pd.DataFrame(uninstall_entry)
        df1.to_csv("/Users/koyko/Documents/installer.csv", index=False, mode="a")
        for guid in user_assist.GUIDS:
            try:
                subkey = regNT.get_key(r'{}\{}'.format(user_assist.USER_ASSIST_KEY_PATH, guid))
                count_subkey = subkey.get_key('Count')
                if not count_subkey.values_count:
                    continue
                for value in count_subkey.iter_values():
                    name = codecs.decode(value.name, encoding='rot-13')
                    if name in user_assist.WHITELISTED_NAMES:
                        continue
                    for k, v in user_assist.GUID_TO_PATH_MAPPINGS.items():
                        if k in name:
                            name = name.replace(k, v)
                            break
                    entry = None
                    data = value.value
                    if len(data) == 72:
                        parsed_entry = user_assist.WIN7_USER_ASSIST.parse(data)
                        entry = {
                            'name': name,
                            'timestamp': convert_wintime(parsed_entry.last_execution_timestamp, as_json=True),
                            'run_counter': parsed_entry.run_counter,
                            'focus_count': parsed_entry.focus_count,
                            'total_focus_time_ms': parsed_entry.total_focus_time_ms,
                            'session_id': parsed_entry.session_id
                        }
                    if entry:
                        df2 = pd.DataFrame.from_dict([entry])
                        df2.to_csv("/Users/koyko/Documents/userassist.csv", header=False, index=False, mode="a")  # remain preprocess only relevant data
            except RegistryKeyNotFoundException:
                continue
        #print(usr_assist)
        try:
            installer_subkey = regNT.get_key(r'\Software\Classes\Installer\Product')
            installSW = []
            for entry in installer_subkey.iter_subkeys():
                identifier = entry.name
                timestamp = convert_wintime(entry.header.last_modified, as_json=True)
                product_name = entry.get_value('ProductName')
                installSW.append({
                    'identifier': identifier,
                    'timestamp': timestamp,
                    'product_name': product_name,
                    'is_hidden': product_name is None})
            df3 = pd.DataFrame(installSW)
            df3.to_csv("/Users/koyko/Documents/installer.csv", header=False, index=False,
                      mode="a")  # remain preprocess only relevant data
        except RegistryKeyNotFoundException:
            pass

    def getTempFiles(self, filename):
        resources = []
        if os.path.exists('/Users/koyko/Documents/prefetch.csv'):
            with open('/Users/koyko/Documents/prefetch.csv') as csvfile:
                reader = csv.DictReader(csvfile)
                csv.field_size_limit(100000000)
                try:
                    for row in reader:
                        if row['All loaded resources'] != "":
                            resources.append(str(row['All loaded resources']))
                except:
                    pass
        if resources:
            for res in resources:
                resItem = res.split("\\")[-1].lower()  # if has extension .split(".")[-1]
                if str(filename).split("/")[-1].lower() == resItem:  # compared temp files with loaded prefetch resources
                    with open(filename, "rb") as tmpF:
                        line = tmpF.read().decode('ISO-8859-1')
                        if line[0:2] == "MZ":
                            malF = pathlib.Path(filename)
                            testTemp = Static_Main.PEAnalysis(malF)
                            if testTemp.get_BinaryResult() is not None:
                                self.tempResult.append(testTemp.get_BinaryResult())
                        else:
                            pass
                    return self.tempResult
            uniq_temp = []
            if self.tempResult:
                for tem in self.tempResult:
                    if tem not in uniq_temp:
                        uniq_temp.append(tem)
            else:
                uniq_temp.append("Not exist")
            return uniq_temp
        else:
            return None

    def analyzeTempFile(self):
        result = []
        uniq_temp = []
        for files_path in os.scandir("/Users/koyko/Documents"):
            if files_path.name.endswith("_UsrTemp") or files_path.name.endswith("_SysTemp"):
                print("User and System Temporary Files")
                if len(os.listdir(pathlib.Path(files_path))) != 0:
                    for file in pathlib.Path(files_path).rglob('*.[TtDdSs][MmLlYy][PpLlSs]'):
                        result.append(self.getTempFiles(pathlib.Path(file).resolve().as_posix()))
                else:
                    pass  # remain preprocess only relevant data [Pp][Yy]

    def getLNKFiles(self, indataS):
        try:
            x = LnkParse3.lnk_file(indataS)
            df = pd.DataFrame([x.get_json()])
            df.to_csv("/Users/koyko/Documents/lnkFile.csv", index=False, header=False,mode="a")  # remain preprocess only relevant data
            #with open('/Users/koyko/Documents/lnkFile.txt', "a") as lnkF:
                #json.dump(x.get_json(), lnkF)  # keep only relevant data and write to csv
        except:
            pass
        indataS.close()

    def analyzePrefetch(self):
        try:
            pref = w10pf_parse.Prefetch(str(self.malware_path).split("/")[-1])
            prefetch_output, roam_file = pref.parse_dir(pathlib.Path("/Users/koyko/Documents/Result_Prefetch"))
            pref.outputResults(prefetch_output)
            if roam_file:
                print(roam_file)
                if os.path.exists("/Users/koyko/Documents/procList.csv"):
                    df_tid = pd.read_csv("/Users/koyko/Documents/procList.csv")
                    for roam in roam_file:
                        if str(roam).lower() != "svchost.exe":
                            for ta in df_tid.astype('str').values:
                                if str(roam).lower() == str(ta[2]).lower():
                                    self.pid.append(str(ta[0]))
                                if ".exe" in str(roam).lower():
                                    self.pid.append(str(roam).lower())
                    self.pid = list(set(self.pid))
                    print(self.pid)
        except:
            pass
        self.noribenExtraction()
    
    def analyzeEVTMem(self):
        try:
            self.vmMalware.suspendVM()
            print("Suspending VM")
            time.sleep(5)
            self.vmMalware.takeSnapshot()
            print("Taking a snapshot")
            time.sleep(5)
            memArtefact = memoryExtraction.Memory(self.pid, str(self.malware_path).split("/")[-1])
            memArtefact.getSnapshotVM()
            memArtefact.extractMemory()
        except:
            pass

    def analyzeArtifacts(self):
        self.analyzeTempFile()
        for files_path in os.scandir("/Users/koyko/Documents"):
            if files_path.name.endswith("WinEVT"):
                eventLogs.parse_dir(pathlib.Path("/Users/koyko/Documents/Result_WinEVT"))
            elif files_path.name.endswith("_Registry"):
                print("Registry Hives")
                for regfiles in os.scandir(files_path):
                    regK = pathlib.Path(regfiles)
                    if regfiles.name.lower() == "system":
                        print("System Hive")
                        self.getSystemHive(regK)
                    elif regfiles.name.lower() == "software":
                        print("Software Hive")
                        self.getSoftwareHive(regK)
                    elif regfiles.name.lower() == "ntuser.dat":
                        print("NTUser Hive")
                        self.getNTUserHive(regK)
                    else:
                        pass # write to csv and keep only relevant data and write to csv
                currentV_list = []
                df = pd.read_csv("/Users/koyko/Documents/currentV.csv")
                if os.path.exists('/Users/koyko/Documents/installer.csv'):
                    df1 = pd.read_csv("/Users/koyko/Documents/installer.csv")
                    for index, row in df.iterrows():
                        try:
                            if row["Is_corrupted"] != '':
                                currentV_list.append(row)
                        except:
                            pass
                if os.path.exists('/Users/koyko/Documents/prefetch.csv'):
                    df2 = pd.read_csv('/Users/koyko/Documents/prefetch.csv')
                    df2["Is_corrupted"] = df2.apply(lambda df2: pd.DataFrame(currentV_list).values.tolist(), axis=1)
                    df2["service_name"] = df2.apply(lambda df2: df1["service_name"].iat[0], axis=1)
                    df2["timestamp"] = df2.apply(lambda df2: max(df1["timestamp"].astype('str')), axis=1)
                    df2["display_name"] = df2.apply(lambda df2: df1["display_name"].iat[0], axis=1)
                    df2["display_icon"] = df2.apply(lambda df2: df1["display_icon"].iat[0], axis=1)
                    df2["display_version"] = df2.apply(lambda df2: df1["display_version"].iat[0], axis=1)
                    df2["publisher"] = df2.apply(lambda df2: df1["publisher"].iat[0], axis=1)
                    df2["uninstall_string"] = df2.apply(lambda df2: df1["uninstall_string"].iat[0], axis=1)
                    df2["estimated_size"] = df2.apply(lambda df2: df1["estimated_size"].iat[0], axis=1)
                    df2["url_info_about"] = df2.apply(lambda df2: df1["url_info_about"].iat[0], axis=1)
                    df2["modify_path"] = df2.apply(lambda df2: df1["modify_path"].iat[0], axis=1)
                    df2["no_elevate_on_modify"] = df2.apply(lambda df2: df1["no_elevate_on_modify"].iat[0], axis=1)
                    df2["quiet_uninstall_string"] = df2.apply(lambda df2: df1["quiet_uninstall_string"].iat[0], axis=1)
                    df2.to_csv('/Users/koyko/Documents/prefetch.csv', index=False)
            elif files_path.name.endswith("_ActivityC"):  # Windows 10 Timeline
                print("Activity Database")
                # ref: https://github.com/forensicmatt/ActivitiesCacheParser
                try:
                    con = lite.connect(os.path.join(files_path, "ActivitiesCache.db"))
                    #cur = con.cursor()
                    activity = pd.read_sql_query('SELECT * FROM Activity', con)
                    activityOp = pd.read_sql_query('SELECT * FROM ActivityOperation', con)
                    activityPa = pd.read_sql_query('SELECT * FROM Activity_PackageId', con)
                    activity.to_csv('/Users/koyko/Documents/activity.csv', index=False, header=True)
                    activityOp.to_csv('/Users/koyko/Documents/activityOperation.csv', index=False, header=True)
                    activityPa.to_csv('/Users/koyko/Documents/activityPackage.csv', index=False, header=True)
                    df_csv = pd.read_csv("/Users/koyko/Documents/activityPackage.csv")
                    df_csv1 = pd.read_csv("/Users/koyko/Documents/activity.csv")
                    df_csv1["Platform"] = df_csv1.apply(
                        lambda df_csv1: str(df_csv[(df_csv["ActivityId"] == df_csv1["Id"])]["Platform"].iat[0]), axis=1)
                    df_csv1["PackageName"] = df_csv1.apply(
                        lambda df_csv1: str(df_csv[(df_csv["ActivityId"] == df_csv1["Id"])]["PackageName"].iat[0]),
                        axis=1)
                    df_csv1.to_csv('/Users/koyko/Documents/activity.csv', index=False)
                    activity_list = []
                    df = pd.read_csv('/Users/koyko/Documents/activity.csv')
                    for index, row in df.iterrows():
                        try:
                            if re.findall(r'(test.exe|winword.exe)', str(row['PackageName'])):
                                # row["Executable Name"] = "test.exe"
                                activity_list.append(row)
                        except:
                            pass
                    if activity_list:
                        df1 = pd.DataFrame(activity_list).drop_duplicates()
                        df2 = pd.read_csv('/Users/koyko/Documents/prefetch.csv')
                        df2["ActivityType"] = df2.apply(lambda df2: df1["ActivityType"].drop_duplicates().to_list(),
                                                        axis=1)
                        df2["ActivityStatus"] = df2.apply(lambda df2: df1["ActivityStatus"].drop_duplicates().to_list(),
                                                          axis=1)
                        df2["ActivityStatus"] = df2.apply(lambda df2: df1["Payload"].drop_duplicates().to_list(),
                                                          axis=1)
                        df2["Priority"] = df2.apply(lambda df2: df1["Priority"].drop_duplicates().to_list(), axis=1)
                        df2["StartTime"] = df2.apply(lambda df2: min(df1["StartTime"].drop_duplicates().to_list()),
                                                     axis=1)
                        df2["EndTime"] = df2.apply(lambda df2: max(df1["EndTime"].drop_duplicates().to_list()), axis=1)
                        df2["LastModifiedOnClient"] = df2.apply(
                            lambda df2: max(df1["LastModifiedOnClient"].drop_duplicates().to_list()),
                            axis=1)  # LastModifiedOnClient may be empty. It is filled out only when users themselves modify files.
                        df2["Platform"] = df2.apply(lambda df2: df1["Platform"].drop_duplicates().iat[0], axis=1)
                        df2.to_csv('/Users/koyko/Documents/prefetch.csv', index=False)
                    con.close()
                except:
                    pass
                # names = [tup[1] for tup in cur.fetchall()]
                # print(names)

            elif files_path.name.endswith("_['Windows Defender']"):
                print("Windows Defender Logs")
                # ref: https://pythonicways.wordpress.com/2016/12/20/log-file-parsing-in-python/
                for file in os.scandir(files_path):
                    if file.name.startswith("MPLog") and file.name.endswith(".log"):
                        with open(pathlib.Path(file), "rb") as fR:
                            line = fR.read().decode('utf-16')
                            with open('/Users/koyko/Documents/dumpLog.txt', 'w') as f:  # dump database to file
                                for data in line.splitlines():
                                    f.write('%s\n' % data)
                        output = []
                        if os.path.exists('/Users/koyko/Documents/prefetch.csv'):
                            df2 = pd.read_csv('/Users/koyko/Documents/prefetch.csv')
                            with open('/Users/koyko/Documents/dumpLog.txt', 'r') as r:
                                lineLog = r.read()
                                indexStart = [match.start() for match in re.finditer("BEGIN BM telemetry", lineLog)] #32044
                                indexEnd = [match.start() for match in re.finditer("END BM telemetry", lineLog)] #32481
                                try:
                                    if len(indexStart) == 1:
                                        output.append(lineLog[indexStart[0]+18:indexEnd[0]].lstrip("\n").splitlines())
                                    else:
                                        for sof in range(len(indexStart)):
                                            output.append(lineLog[indexStart[sof] + 18:indexEnd[sof]].strip())
                                except:
                                    pass
                                telemetry = []
                                guid_Defender = []
                                signatureID = []
                                processID_Defender = []
                                creationTime = []
                                imagePath = []
                                targetFileName = []
                                if output:
                                    for guid in output:
                                        guid_Defender.append(guid.splitlines()[0].split(":", 1)[1])
                                        telemetry.append(guid.splitlines()[1].split(":", 1)[1])
                                        signatureID.append(guid.splitlines()[2].split(":", 1)[1])
                                        processID_Defender.append(guid.splitlines()[3].split(":", 1)[1])
                                        creationTime.append(guid.splitlines()[6].split(":", 1)[1])
                                        imagePath.append(guid.splitlines()[7].split(":", 1)[1])
                                        if "TargetFileName" in guid:
                                            targetFileName.append(guid.splitlines()[9].split(":", 1)[1])
                                    df2["GUID_Defender"] = df2.apply(lambda df2: pd.DataFrame(guid_Defender).values.tolist(), axis=1)
                                    df2["TelemetryName"] = df2.apply(lambda df2: pd.DataFrame(telemetry).values.tolist(),
                                                                         axis=1)
                                    df2["SignatureID"] = df2.apply(lambda df2: pd.DataFrame(signatureID).values.tolist(), axis=1)
                                    df2["ProcessID_Defender"] = df2.apply(lambda df2: pd.DataFrame(processID_Defender).values.tolist(), axis=1)
                                    df2["CreationTime"] = df2.apply(lambda df2: pd.DataFrame(creationTime).values.tolist(),
                                                                        axis=1)
                                    df2["ImagePath"] = df2.apply(lambda df2: pd.DataFrame(imagePath).values.tolist(), axis=1)
                                    if targetFileName:
                                        df2["TargetFileName"] = df2.apply(lambda df2: pd.DataFrame(targetFileName).values.tolist(),
                                                                          axis=1)
                                    df2.to_csv('/Users/koyko/Documents/prefetch.csv', index=False)
            elif files_path.name.endswith("_LNK"):  # lnk parser
                lnk_file = []
                print("LNK files")
                with open("/Users/koyko/Documents/lnkFile.csv", "w") as f:
                    csvWriter = csv.DictWriter(f, fieldnames=["header", "data", "link_info", "extra"])
                    csvWriter.writeheader()
                # ref: https://medium.com/@bromiley/scripting-saturday-pylnk-c49bc5764cab
                # ref: https://github.com/silascutler/LnkParse/tree/master/docs
                # ref: https://github.com/Bhupipal/JumpListParser/blob/master/JumpListParser.py
                for lnkfile in os.scandir(files_path):
                    if lnkfile.is_dir():
                        for subfile in os.scandir(lnkfile):
                            indataS = open(pathlib.Path(subfile), 'rb')
                            self.getLNKFiles(indataS)
                    else:
                        indata = open(lnkfile, 'rb')
                        self.getLNKFiles(indata)
                lnk_file = []
                df1 = pd.read_csv("/Users/koyko/Documents/lnkFile.csv")
                if os.path.exists('/Users/koyko/Documents/prefetch.csv'):
                    df2 = pd.read_csv('/Users/koyko/Documents/prefetch.csv')
                    for index, row in df1.iterrows():
                        try:
                            if re.findall(r'(test.exe|winword.exe|powershell.exe)', row["Description"]) or str(self.malware_path).split("/")[-1].split(".")[0].lower()[0:5] in row["Description"]:
                                lnk_file.append(row)
                                df3 = pd.DataFrame(lnk_file).drop_duplicates()
                                df2["GUID_LNK"] = df2.apply(lambda df2: df3["header"].drop_duplicates().tolist(), axis=1)
                                df2["Description"] = df2.apply(lambda df2: df3["data"].drop_duplicates().tolist(),
                                                               axis=1)
                                df2["Link_info"] = df2.apply(lambda df2: df3["link_info"].drop_duplicates().tolist(),
                                                             axis=1)
                                df2["Metadata"] = df2.apply(lambda df2: df3["extra"].drop_duplicates().tolist(), axis=1)
                                df2.to_csv('/Users/koyko/Documents/prefetch.csv', index=False)
                        except:
                            pass
            elif files_path.name == "outNoriben.csv":
                success_closeFile = []
                success_createFile = []
                success_createFileMap = []
                success_loadImage = []
                success_procExit = []
                success_procStart = []
                success_queryBase = []
                success_queryName = []
                success_queryStandard = []
                success_querySec = []
                success_readFile = []
                success_regClose = []
                success_regEnumK = []
                success_regEnumV = []
                success_regOpen = []
                success_regQK = []
                success_regQM = []
                success_regQV = []
                success_regSetInfo = []
                success_threadCreate = []
                success_threadExit = []
                fileLock = []
                notfound = []
                reparse = []
                df = pd.read_csv("/Users/koyko/Documents/outNoriben.csv")
                if os.path.exists('/Users/koyko/Documents/prefetch.csv'):
                    df2 = pd.read_csv('/Users/koyko/Documents/prefetch.csv')
                    for index, row in df.iterrows():
                        try:
                            if "SUCCESS" in row['Result']:
                                if "CloseFile" in row['Operation']:
                                    if str(row["Detail"]) is np.nan:
                                        success_regQM.append(str(row["Path"]))
                                    else:
                                        success_closeFile.append(str(row["Path"]) + "->>" + str(row["Detail"]))
                                elif "CreateFile" in row['Operation']:
                                    success_createFile.append(str(row["Path"]))
                                elif "FileMapping" in row['Operation']:
                                    success_createFileMap.append(str(row["Path"]) + "->>" + str(row["Detail"]))
                                elif "Load Image" in row['Operation']:
                                    success_loadImage.append(str(row["Path"]))
                                elif "Process Start" in row['Operation']:
                                    success_procStart.append(str(row["Detail"]))
                                elif "QueryBasicInformationFile" in row['Operation']:
                                    success_queryBase.append(str(row["Path"]))
                                elif "QueryNameInformationFile" in row['Operation']:
                                    success_queryName.append(str(row["Path"]))
                                elif "QuerySecurityFile" in row['Operation']:
                                    success_querySec.append(str(row["Path"]))
                                elif "QueryStandardInformationFile" in row['Operation']:
                                    success_queryStandard.append(str(row["Path"]))
                                elif "ReadFile" in row['Operation']:
                                    success_readFile.append(str(row["Path"]))
                                elif "RegCloseKey" in row['Operation']:
                                    success_regClose.append(str(row["Path"]))
                                elif "RegEnumKey" in row['Operation']:
                                    success_regEnumK.append(str(row["Path"]))
                                elif "RegEnumValue" in row['Operation']:
                                    success_regEnumV.append(str(row["Path"]))
                                elif "RegOpenKey" in row['Operation']:
                                    success_regOpen.append(str(row["Path"]) + "->>" + str(row["Detail"]))
                                elif "RegQueryKey" in row['Operation']:
                                    success_regQK.append(str(row["Path"]) + "->>" + str(row["Detail"]))
                                elif "RegQueryMultipleValueKey" in row['Operation']:
                                    if str(row["Detail"]) is np.nan:
                                        success_regQM.append(str(row["Path"]))
                                    else:
                                        success_regQM.append(str(row["Path"])+ "->>" + str(row["Detail"]))
                                elif "RegQueryValue" in row['Operation']:
                                    success_regQV.append(str(row["Path"]))
                                elif "RegSetInfoKey" in row['Operation']:
                                    success_regSetInfo.append(str(row["Path"]) + "->>" + str(row["Detail"]))
                            if "FILE LOCKED WITH ONLY READERS" in row['Result']:
                                fileLock.append(
                                    str(row["Operation"]) + "->>" + str(row["Path"]) + "->>" + str(row["Detail"]))
                            if "NAME NOT FOUND" in row['Result']:
                                notfound.append(
                                    str(row["Operation"]) + "->>" + str(row["Path"]) + "->>" + str(row["Detail"]))
                            if "REPARSE" in row['Result']:
                                reparse.append(
                                    str(row["Operation"]) + "->>" + str(row["Path"]) + "->>" + str(row["Detail"]))
                        except:
                            pass
                    df2["Result_FileLock"] = df2.apply(lambda df2: pd.DataFrame(fileLock).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_NameNotFound"] = df2.apply(lambda df2: pd.DataFrame(notfound).drop_duplicates().values.tolist(),
                                                               axis=1)
                    df2["Result_Reparse"] = df2.apply(lambda df2: pd.DataFrame(reparse).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_CloseFile"] = df2.apply(lambda df2: pd.DataFrame(success_closeFile).drop_duplicates().values.tolist(),
                                                            axis=1)
                    df2["Result_CreateFile"] = df2.apply(
                            lambda df2: pd.DataFrame(success_createFile).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_CreateFileMap"] = df2.apply(
                            lambda df2: pd.DataFrame(success_createFileMap).values.tolist(), axis=1)
                    df2["Result_LoadImage"] = df2.apply(lambda df2: pd.DataFrame(success_loadImage).values.tolist(),
                                                            axis=1)
                    df2["Result_ProcessStart"] = df2.apply(
                            lambda df2: pd.DataFrame(success_procStart).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_QueryBasicInfoFile"] = df2.apply(
                            lambda df2: pd.DataFrame(success_queryBase).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_QueryNameInfoFile"] = df2.apply(
                            lambda df2: pd.DataFrame(success_queryName).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_QuerySecurityFile"] = df2.apply(
                            lambda df2: pd.DataFrame(success_querySec).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_QueryStandardInfoFile"] = df2.apply(
                            lambda df2: pd.DataFrame(success_queryStandard).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_ReadFile"] = df2.apply(lambda df2: pd.DataFrame(success_readFile).drop_duplicates().values.tolist(),
                                                           axis=1)
                    df2["Result_RegCloseKey"] = df2.apply(
                            lambda df2: pd.DataFrame(success_regClose).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_RegEnumKey"] = df2.apply(lambda df2: pd.DataFrame(success_regEnumK).drop_duplicates().values.tolist(),
                                                             axis=1)
                    df2["Result_RegEnumValue"] = df2.apply(
                            lambda df2: pd.DataFrame(success_regEnumV).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_RegOpenKey"] = df2.apply(lambda df2: pd.DataFrame(success_regOpen).drop_duplicates().values.tolist(),
                                                             axis=1)
                    df2["Result_RegQueryKey"] = df2.apply(lambda df2: pd.DataFrame(success_regQK).drop_duplicates().values.tolist(),
                                                              axis=1)
                    df2["Result_RegQueryMultipleValueKey"] = df2.apply(
                            lambda df2: pd.DataFrame(success_regQM).drop_duplicates().values.tolist(), axis=1)
                    df2["Result_RegQueryValue"] = df2.apply(lambda df2: pd.DataFrame(success_regQV).drop_duplicates().values.tolist(),
                                                                axis=1)
                    df2["Result_RegSetInfoKey"] = df2.apply(
                            lambda df2: pd.DataFrame(success_regSetInfo).drop_duplicates().values.tolist(), axis=1)
                    df2.to_csv('/Users/koyko/Documents/prefetch.csv', index=False)
            elif files_path.name.endswith("_JumpList"):
                print("Jump List")
                listOfFiles = []
                for (dirpath, dirnames, filenames) in os.walk(pathlib.Path(files_path)):
                    listOfFiles += [os.path.join(dirpath, file) for file in filenames]
                for jumpFile in listOfFiles:
                    if str(jumpFile).endswith(".lnk"):
                        indata = open(jumpFile, 'rb')
                        self.getLNKFiles(indata)
                    if str(jumpFile).endswith("automaticDestinations-ms") or str(jumpFile).endswith(
                                "customDestinations-ms"):
                        subdata = b""
                        try:
                            jmpFile = olefile.OleFileIO(jumpFile)
                            for item in jmpFile.listdir():
                                file = jmpFile.openstream(item)
                                file_data = file.read()
                                header_value = file_data[:4]  # first four bytes value should be 76 byte
                                if header_value[0] == 76:  # first four bytes value should be 76 bytes
                                    with open(jumpFile, "rb") as jumpF:
                                        binfile = jumpF.read()
                                        if binfile.decode('ISO-8859-1')[0:2] == "MZ" or binfile.hex().startswith(
                                                    "d0"):
                                            hex_content = binascii.hexlify(binfile)
                                            i = 1
                                            if binfile.find(b"\x4C\x00\x00\x00"):
                                                Start_list = [match.start() for match in
                                                                  re.finditer(b"\x4C\x00\x00\x00", binfile)]
                                                EOF_list = [match.start() for match in
                                                                re.finditer(b"\x54\x49\x6d\x00", binfile)]
                                                if EOF_list:
                                                    try:
                                                        for sof in range(0, len(Start_list)):
                                                            subdata = binfile[Start_list[sof]:EOF_list[sof]]
                                                            carve_filename = "Carve_" + \
                                                                                 jumpFile.split("/")[-1].split(".")[
                                                                                     0] + "_" + str(
                                                                    i) + ".lnk"
                                                            with open(carve_filename, 'wb') as carve_obj:
                                                                    carve_obj.write(subdata)
                                                            indata1 = open(carve_filename, 'rb')
                                                            self.getLNKFiles(indata1)
                                                            i += 1
                                                    except:
                                                        pass
                                                else:
                                                    for sof in range(0, len(Start_list)):
                                                        subdata = binfile[Start_list[sof]:len(binfile) - 100]
                                                        carve_filename = "Carve_" + \
                                                                             jumpFile.split("/")[-1].split(".")[
                                                                                 0] + "_" + str(
                                                                i) + ".lnk"
                                                        with open(carve_filename, 'wb') as carve_obj:
                                                            carve_obj.write(subdata)
                                                        indata2 = open(carve_filename, 'rb')
                                                        self.getLNKFiles(indata2)
                                                        i += 1
                                            elif binfile.find(b"\x60\x00\x00\x00"):
                                                Start_deleted = [match.start() for match in
                                                                     re.finditer(b"\x60\x00\x00\x00", binfile)]
                                                try:
                                                    lnk_tracker = JumpListParser.lnk_file_tracker_data(
                                                            binfile[Start_deleted:])
                                                    df = pd.DataFrame.from_dict([lnk_tracker])
                                                    df.to_csv("/Users/koyko/Documents/lnkFile.csv", header=False, index=False, mode="a")
                                                except:
                                                    pass
                                else:
                                    JumpListParser.destlist_data(file_data[:jmpFile.get_size(item)])
                        except:
                            pass #remain preprocess only relevant data

    def remove_artifacts(self):
        # remove all files in documents folder
        fileList = glob.glob('/Users/koyko/Documents/*', recursive=True)
        # Iterate over the list of filepaths & remove each file.
        for filePath in fileList:
            try:
                os.remove(filePath)
            except OSError:
                print("Error while deleting file")
        # also remove parsing evidence

    def write_output(self, file):
        final_output = {}
        df_pf = pd.read_csv('/Users/koyko/Documents/prefetch.csv')
        with open("combined_output.csv", "wb") as outfile:
            writer = csv.writer(outfile, delimiter=",", quoting=csv.QUOTE_ALL, quotechar="'")
            final_output.update({"Real Filename": file, "Run Count":df_pf["Run Count"], "Last Run Time": df_pf["Last Run Time 0"]})
            writer.writerow(final_output)
        #self.remove_artifacts()

#####################################################Main part#########################################################
def main():
    for root, dir, files in os.walk("/Users/koyko/Downloads/Test"):
        for file in files:
            print(str(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')) + " Dynamic Filename: " + file)
            testDynamic = PEDynamic(os.path.join(root, file))
            #testDynamic.vmMalware.powerOn()
            print("Poweron VM")
            time.sleep(5)
            testDynamic.disableRTP()
            #testDynamic.write_output(file)
if __name__ == '__main__':
    main()
