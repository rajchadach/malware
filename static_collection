import binascii
import pefile
from pdbparse.dbgold import CV_RSDS_HEADER
import array
import os, sys, struct
import json
from hachoir.parser import createParser
# import zugbruecke as ctypes
from hachoir.core import config
from hachoir.metadata import extractMetadata
from capstone import *
#import macro
from olefile import olefile
import mimetypes
import yara
import hashlib
import datetime
import csv
import re
import subprocess
import PyPDF2
from pdfminer.converter import TextConverter
from pdfminer.pdfinterp import PDFPageInterpreter, PDFResourceManager
from pdfminer.pdfpage import PDFPage, PDFTextExtractionNotAllowed
from pdfminer.pdfparser import PDFParser
from pdfminer.pdfdocument import PDFDocument
import io
import pdfrw
import base64
import pandas as pd
import zipfile
from oletools import olevba, oleid
from xml.etree import ElementTree as etree
import multiprocessing
#from numba import jit
import math, operator
from PIL import Image, ImageChops, ImageStat
import numpy as np
import pathlib
from time import time
import string
import exiftool
import requests
import richHeader
import apialert
import json


class PEAnalysis(object):

    def __init__(self, malware_path):
        self.malware_path = malware_path
        self.sumOfRawData = 0

    def getPEFile(self):
        malware_file = pefile.PE(self.malware_path)
        return malware_file

    # ref: https://stackoverflow.com/questions/3207219/how-do-i-list-all-files-of-a-directory
    def getImageBase(self):
        # print("[*] e_magic value: %s" % hex(malware_file.DOS_HEADER.e_magic))
        # print("[*] Signature value: %s" % hex(malware_file.NT_HEADERS.Signature))
        imageBase = self.getPEFile().OPTIONAL_HEADER.ImageBase
        if imageBase == 4194304 or imageBase == 268435456 or imageBase == 536870912:
            status = "Default ImageBase"
        else:
            status = "Suspicious ImageBase: " + str(hex(imageBase))
        return status


    def getInitializedData(self):
        return int(hex(self.getPEFile().OPTIONAL_HEADER.SizeOfInitializedData), 16)


    def getCodeSize(self):
        return int(hex(self.getPEFile().OPTIONAL_HEADER.SizeOfCode), 16)


    def getNumberSections(self):
        # An application for Windows NT has 9 pre-defined sections named .text, .bss, .rdata, .data, .rsrc, .edata, .idata, .pdata and .debug.
        if self.getPEFile().FILE_HEADER.NumberOfSections > 9:
            status = "Suspicious Sections"
        else:
            status = "Normal Sections"
        return status


    def getFileSize(self):
        return os.stat(self.malware_path).st_size

    def getEntropy(self):
        entropy_section = []
        try:
            for section in self.getPEFile().sections:
                if section.get_entropy() >= 6:
                    entropy_section.append(
                        {"Section Name": str(section.Name, 'utf-8').encode('ascii').strip(b'\x00').decode(
                            'ascii'), "Entropy": section.get_entropy()})
                self.sumOfRawData += section.SizeOfRawData
            # print("data: " + str(section.get_data())[:50])
        except:
            return None
        return entropy_section, self.sumOfRawData

    def getPacker(self):
        entropySection = []
        try:
            entropy, sumRaw = self.getEntropy()
            if entropy:
                for val in entropy:
                # print("Sum of SizeOfRawData field of all sections is " + sumOfRawData + " which is not greater than the file size.")
                    entropySection.append(val["Section Name"])
                if len(entropySection) == 1:
                    return str(entropySection[0])
                else:
                    return entropySection
        except:
            return None

    def getMaxEntropy(self):
        entropyVal = []
        try:
            entropy, sumRaw = self.getEntropy()
            if entropy:
                for val in entropy:
                    entropyVal.append(val["Entropy"])
                if len(entropyVal) == 1:
                    return str(entropyVal[0])
                else:
                    return max(entropyVal)
        except:
            return None

    def getSumOfRawData(self):
        try:
            entropy, sumRaw = self.getEntropy()
            if sumRaw is not None:
                if sumRaw < self.getFileSize():
                    statusRaw = "Normal Raw Data Size"
                else:
                    statusRaw = "Suspicious Raw Data Size"
            else:
                statusRaw = "N/A"
        except:
            return None
        return statusRaw

    def getImphash(self):
        if self.getPEFile().get_imphash():
            return self.getPEFile().get_imphash()
        else:
            return None

    def getImportedList(self):
        # print("[*] Listing imported DLLs...")
        imported_dll = {}
        try:
            for entry in self.getPEFile().DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8')
                # if dll_name == "ADVAPI32.dll":
                # print("Enc/Dec is implemented")
                # if dll_name == "WSOCK32.dll" or dll_name == "WININET.dll" or dll_name == "WS2_32.dll":
                # print("Establish network connection")
                # print("[*] " + dll_name + " imports:")
                importEntry = []
                for func in entry.imports:
                    # print("\t%s at 0x%08x" % (func.name.decode('utf-8'), func.address))
                    importEntry.append(func.name.decode('utf-8'))
                imported_dll[dll_name] = importEntry
            return imported_dll
        except:
            return None
    def getSuspiciousImportedEntries(self):
        dllList = self.getImportedList()
        suspicious_entries = []
        try:
            if dllList:
                for func_api in dllList.values():
                    if ("GetProcAddress" in func_api and "LoadLibraryA" in func_api) or "LoadLibraryExW" in func_api or "VirtualProtect" in func_api or "FreeLibrary" in func_api or "GetModuleFileNameA" in func_api:
                        suspicious_entries.append("Suspicious DLL Loaded")
                    if "RegOpenKeyExW" in func_api or "RegQueryValueExW" in func_api or "RegCreateKeyExW" in func_api or "RegQueryValueExA" in func_api:
                        suspicious_entries.append("Registry Manipulation")
                        # Usually the access token is obtained by doing the OpenProcessToken syscall, Then the malware calls the LookupPrivilegeValueA syscall,
                        # necessary to retrieve the locally unique identifier (LUID). Lastly, AdjustTokenPrivileges function in File Imports, ADVAPI32.dll used by malware to gain additional permissions.
                    if "GetSidSubAuthority" in func_api or "GetUserNameW" in func_api or "AdjustTokenPrivileges" in func_api:
                        suspicious_entries.append("Attempt to escalate privilege")
                    if "OpenProcessToken" in func_api or "GetTokenInformation" in func_api or "DuplicateTokenEx" in func_api:
                        suspicious_entries.append("Retrieve token information")
                    if "RegisterHotKey" in func_api or "GetKeyboardLayoutNameW" in func_api or "GetForegroundWindow" in func_api or "SendInput" in func_api or "GetKeyState" in func_api or "MapVirtualKeyW" in func_api:
                        suspicious_entries.append("Keylogger")
                    if "GetDC" in func_api or "CreateCompatibleBitmap" in func_api or "CreateCompatibleDC" in func_api:
                        suspicious_entries.append("Screenshot")
                    if "CreateFileW" in func_api or "WriteFile" in func_api or "MoveFileW" in func_api or "GetTempFileNameW" in func_api or "DeleteFileW" in func_api or "GetFileAttributesA" in func_api:
                        suspicious_entries.append("File Manipulation")
                    if "CryptGenKey" in func_api or "CryptGenRandom" in func_api or "CryptDestroyKey" in func_api or "CryptGetKeyParam" in func_api or "CryptImportKey" in func_api or "CryptExportKey" in func_api:
                        suspicious_entries.append("Encrypt/Decrypt")
                    if "gethostbyname" in func_api or "InternetOpenUrlA" in func_api or "InternetReadFile" in func_api or "HttpQueryInfoA" in func_api or "InternetConnectA" in func_api or "HttpOpenRequestA" in func_api or "InternetCloseHandle" in func_api or "InternetOpenA" in func_api or "DeleteUrlCacheEntryW" in func_api or "URLDownloadToFileA" in func_api:
                        suspicious_entries.append("Establish network connection")
                    if "CreateToolhelp32Snapshot" in func_api or "Process32FirstW" in func_api or "Process32First" in func_api or "Process32NextW" in func_api or "Process32Next" in func_api or "OpenProcess" in func_api or "VirtualQueryEx" in func_api or "ReadProcessMemory" in func_api:
                        suspicious_entries.append("Enumerate process")
                    if "VirtualAllocEx" in func_api or "CreateRemoteThread" in func_api or "WriteProcessMemory" in func_api:
                        suspicious_entries.append("Code injection")
                suspicious_unique = []
                if suspicious_entries:
                    for se in suspicious_entries:
                        if se not in suspicious_unique:
                            suspicious_unique.append(se)
                    if len(suspicious_unique) == 1:
                        return str(suspicious_unique[0])
                    else:
                        return suspicious_unique
                else:
                    return "N/A"
        except:
            return None

    def getDllList(self):
        dllList = self.getImportedList()
        if dllList:
            if len(list(dllList.keys())) == 1:
                return str(list(dllList.keys())[0])
            elif not list(dllList.keys()):
                return "N/A"
            else:
                return list(dllList.keys())
        else:
            return None

    def getKernelDll(self):
        dllList = self.getImportedList()
        if dllList:
            for key,val in dllList.items():
                if "kernel32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None
    def getNTDll(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "ntdll.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None
    def getATAPORT(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "ataport.sys" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCP90(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcp90.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getWINMM(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "winmm.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getGDI32(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "gdi32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getNTOSKRNL(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "ntoskrnl.exe" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getWS232(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "ws2_32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCRT(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcrt.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getSetupAPI(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "setupapi.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getCompCTL(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "comctl32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getUser32(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "user32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getPSAPI(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "psapi.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getOLEAUT(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "oleaut32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getADVAPI(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "advapi32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getRPCRT(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "rpcrt4.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getSHELL32(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "shell32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getWinInet(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "wininet.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getUSBPort(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "usbport.sys" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getHAL(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "hal.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCM80(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcm80.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCM90(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcm90.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getCrypt32(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "crypt32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getWinTrust(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "wintrust.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getCOMDLG32(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "comdlg32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getUserEnv(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "userenv.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getSHLWAPI(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "shlwapi.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getDNSAPI(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "dnsapi.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getVersionDll(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "version.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getWINMM(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "winmm.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getSecur32(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "secur32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getWinSpool(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "winspool.drv" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getOLE32(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "ole32.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCR90(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcr90.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getIPHL(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "iphlpapi.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCP80(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcp80.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getOLEACC(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "oleacc.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getSHL(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "shlwapi.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getWMILIB(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "wmilib.sys" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getUrlMon(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "urlmon.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None
    def getGDIPlus(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "gdiplus.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCR80(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcr80.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSVCR110(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "msvcr110.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getMSCOREE(self):
        dllList = self.getImportedList()
        if dllList:
            for key, val in dllList.items():
                if "mscoree.dll" == key.lower():
                    if len(val) == 1:
                        return str(val[0])
                    else:
                        return val
                else:
                    pass
        else:
            return None

    def getOthersDll(self):
        dllList = self.getImportedList()
        not_common = {}
        common_dlls = ["mscoree.dll", "kernel32.dll", "msvcr110.dll", "msvcr80.dll", "ntdll.dll", "ataport.sys", "msvcp90.dll", "winmm.dll", "gdi32.dll", "ntoskrnl.exe",
                       "ws2_32.dll", "msvcrt.dll", "setupapi.dll", "comctl32.dll", "user32.dll", "psapi.dll", "oleaut32.dll",
                       "advapi32.dll", "rpcrt4.dll", "shell32.dll", "wininet.dll", "usbport.sys", "hal.dll", "msvcm80.dll", "msvcm90.dll", "crypt32.dll", "version.dll",
                       "wintrust.dll", "comdlg32.dll", "userenv.dll", "shlwapi.dll", "dnsapi.dll", "secur32.dll", "winspool.drv", "ole32.dll",
                       "msvcr90.dll", "iphlpapi.dll", "msvcp80.dll", "oleacc.dll", "shlwapi.dll", "wmilib.sys", "urlmon.dll", "gdiplus.dll"]
        try:
            if dllList:
                for key in dllList.keys():
                    if key.lower() not in common_dlls:
                        not_common.update({key:dllList[key]})
                    else:
                        pass
                if not not_common:
                    return "N/A"
                else:
                    return not_common
            else:
                return None
        except:
            pass

    def getExportedList(self):
        dll_export = []
        try:
            if self.getPEFile().OPTIONAL_HEADER.DATA_DIRECTORY[
                pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT']].VirtualAddress != 0:
                exportSymbols = self.getPEFile().parse_data_directories(
                    directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_EXPORT']])
                for sym in exportSymbols.symbols:
                        # sym.forwarder is for example 'KERNEL32.EnterCriticalSection'
                    dll_export.append(sym.name)
            else:
                pass
            """
                print("[*] Listing exported DLLs...")
                if hasattr(self.getPEFile(), 'DIRECTORY_ENTRY_EXPORT'):
                    for exp in malware_file.DIRECTORY_ENTRY_EXPORT.symbols:
                        print(hex(malware_file.OPTIONAL_HEADER.ImageBase + exp.address), exp.name.decode('utf-8'))
            """
            # print(dll_export)
            return dll_export
        except:
            return None


    def getDebugDir(self):
        debugInfo = []
        debugStatus = "No Debug Information Found"
        DEBUG_TYPE = {
            "IMAGE_DEBUG_TYPE_UNKNOWN": 0,
            "IMAGE_DEBUG_TYPE_COFF": 1,
            "IMAGE_DEBUG_TYPE_CODEVIEW": 2,
            "IMAGE_DEBUG_TYPE_FPO": 3,
            "IMAGE_DEBUG_TYPE_MISC": 4,
            "IMAGE_DEBUG_TYPE_EXCEPTION": 5,
            "IMAGE_DEBUG_TYPE_FIXUP": 6,
            "IMAGE_DEBUG_TYPE_BORLAND": 9,
        }
        __CV_INFO_PDB70_format__ = ('CV_INFO_PDB70', ('4s,CvSignature', '16s,Signature', 'L,Age'))
        # __CV_INFO_PDB70_format__ = ['CV_INFO_PDB70',['I,CvSignature', 'I,Signature_Data1', 'H,Signature_Data2', 'H,Signature_Data3', '8s,Signature_Data4', 'I,Age']]
        try:
            for d in self.getPEFile().OPTIONAL_HEADER.DATA_DIRECTORY:
                if d.name == "IMAGE_DIRECTORY_ENTRY_DEBUG":
                    debug_directories = self.getPEFile().parse_debug_directory(d.VirtualAddress, d.Size)
                    for debug_directory in debug_directories:
                        if debug_directory.struct.Type == DEBUG_TYPE["IMAGE_DEBUG_TYPE_CODEVIEW"]:
                            startOffset = debug_directory.struct.AddressOfRawData
                            data = self.getPEFile().get_memory_mapped_image()[
                                   startOffset:startOffset + debug_directory.struct.SizeOfData]
                            cv = pefile.Structure(__CV_INFO_PDB70_format__)
                            cv.__unpack__(data)
                            cv.PdbFileName = data[cv.sizeof():]
                            dbg = CV_RSDS_HEADER.parse(data)
                            guidstr = u"%08x%04x%04x%s%x" % (
                                dbg.GUID.Data1, dbg.GUID.Data2, dbg.GUID.Data3,
                                binascii.hexlify(dbg.GUID.Data4).decode('ascii'),
                                dbg.Age)
                            debugInfo.append(
                                {"GUID": guidstr,
                                 "PDB Path": str(cv.PdbFileName, 'utf-8').encode('ascii', errors='ignore').strip().decode(
                                     'ascii').rstrip("\x00"),
                                 "Age": dbg.Age})
            if not debugInfo:
                return debugStatus
            else:
                return debugInfo
        except:
            return None
        # Ref: https://github.com/moyix/pdbparse/blob/master/pdbparse/peinfo.py

    def getPDBInfo(self):
        try:
            for pdb in self.getDebugDir():
                pdbData = pdb["PDB Path"]
                if "users" in pdbData.lower() or "documents and settings" in pdbData.lower():
                    return "True"
                else:
                    return "False"
        except:
            return None

    def getManifest(self):
        manifest = open(self.malware_path, "rb").read()
        result = "" # Token Elevation Type (Integrity Level):
        if b'requireAdministrator' in manifest:
            result = "Require administrative"
        else:
            result = "asInvoker"
        return result
        # ref: https://www.ultimatewindowssecurity.com/securitylog/encyclopedia/event.aspx?eventID=4688

    def comparePicture(self, fileImage1):
        # ref: https://www.cs.hmc.edu/~jlevin/ImageCompare.py
        # https://pysource.com/2018/07/20/find-similarities-between-two-images-with-opencv-and-python/
        iconF = ""
        for root, dir, files in os.walk("/content/gdrive/My Drive/Colab Notebooks/icon_repo"):
            for file in files:
                fileImage2 = str(os.path.join("/content/gdrive/My Drive/Colab Notebooks/icon_repo", file))
                image1 = Image.open(fileImage1)
                image2 = Image.open(fileImage2)

                # h = ImageChops.difference(image1, image2).histogram()
                # print(math.sqrt(reduce(operator.add,
                # map(lambda h, i: h * (i ** 2), h, range(256))) / (float(image1.size[0]) * image1.size[1])))

                try:
                    errors = np.asarray(ImageChops.difference(image1, image2)) / 255
                    result = math.sqrt(np.mean(np.square(errors)))
                    max_similarity = 0
                    for x_offset in range(-3, 4, 1):
                        for y_offset in range(-3, 4, 1):
                            diff = ImageChops.difference(ImageChops.offset(image1, x_offset, y_offset), image2)
                            num_pixels = image2.size[0] * image1.size[1]
                            diff_stats = ImageStat.Stat(diff)
                            similarity = 1.0 - ((diff_stats.sum[0] / 255) / num_pixels)
                            max_similarity = max(similarity, max_similarity)
                    if max_similarity > 0.8:
                        if "word" in fileImage2.lower():
                            iconF = "Word Icon file"
                        elif "pdf" in fileImage2.lower():
                            iconF = "Pdf Icon file"
                        elif "access" in fileImage2.lower():
                            iconF = "Access Icon file"
                        elif "excel" in fileImage2.lower():
                            iconF = "Excel Icon file"
                        elif "outlook" in fileImage2:
                            iconF = "Outlook Icon file"
                        elif "onenote" in fileImage2:
                            iconF = "OneNote Icon file"
                        else:
                            iconF = "Not MSOffice/PDF file"
                        return iconF
                    else:
                        return "No icon found"
                except:
                    pass

    def getIconFiles(self):
        exifInfo = []
        meta_images = self.getHiddenFiles()
        try:
          for keyE, val in meta_images.items():
              if meta_images["EXIF:ExifImageWidth"] == meta_images["EXIF:ExifImageHeight"]:
                  imageF = self.comparePicture(meta_images["SourceFile"])
                  exifInfo.append("Icon" + ": " + imageF)
              else:
                  continue
          return exifInfo
        except:
          return "N/A"
    
    def getHiddenFiles(self):
        start_magic_numbers = {'png': b"\x89\x50\x4E\x47", 'jpg': b"\xFF\xD8", 'jpg': b"\x4A\x46", 'jpg': b"\x45\x78",
                               'tiff': b"\x49\x49\x2A\x00",
                               'tiff': b"\x4D\x4D\x00\x2A", 'gif': b"\x47\x49\x46\x38", 'gif': b"\x4D\x4D\x00\x2A",
                               'ico': b"\x00\x00\x01\x00", 'pdf': b"\x25\x50\x44\x46"}
        end_magic_numbers = {'png': b"\x49\x45\x4E\x44", 'jpg': b"\xFF\xD9", 'gif': b"\x00\x3B"}
        temp_list = []
        subdata = b""
        unique = []
        metadata_images = []
        with open(self.malware_path, "rb") as binary_file:
            binfile = binary_file.read()
            if binfile.decode('ISO-8859-1')[0:2] == "MZ" or binfile.hex().startswith("d0"):
                hex_content = binascii.hexlify(binfile)
                for start in start_magic_numbers.keys():
                    for end in end_magic_numbers.keys():
                        if start == end or isinstance(start, dict):
                            # Find SOI markers
                            # index = hex_content.find(start, 0)
                            if binfile.find(start_magic_numbers[start]) and binfile.find(end_magic_numbers[end]):
                                soi = bytes(start_magic_numbers[start])
                                eoi = bytes(end_magic_numbers[end])

                                Start_list = [match.start() for match in re.finditer(soi, binfile)]
                                EOF_list = [match.start() for match in re.finditer(eoi, binfile)]

                                for sof in range(0, len(Start_list)):
                                    if len(Start_list) < len(EOF_list):
                                        if Start_list[sof] < EOF_list[sof]:
                                            subdata = binfile[Start_list[sof]:EOF_list[sof]]

                                    if not EOF_list:
                                        # binary_file.seek(0)
                                        last_byte = len(binfile)
                                        subdata = binfile[Start_list[sof]:last_byte - 1]

                                    carve_filename = "Carve_" + self.malware_path.split("/")[-1].split(".")[
                                        0] + "." + start

                                    with open(carve_filename, 'wb') as carve_obj:
                                        carve_obj.write(subdata)
                                    if os.stat(carve_filename).st_size > 0:
                                        temp_list.append(carve_filename)
        for cf in temp_list:
            if cf not in unique:
                unique.append(cf)
        for image in unique:
            with exiftool.ExifTool() as et:
                metadata_images.append(et.get_metadata(image))
        return metadata_images

    def getRichHeader(self):
        # https://github.com/kirschju/richheader/blob/master/rich.py
        checksum = ""
        try:
            richH = richHeader.parse(self.malware_path)
            if richH['err'] < 0:
                #print("\x1b[33m[-] " + richHeader.err2str(richH['err']) + "\x1b[39m")
                sys.exit(richH['err'])
            richStatus, checksum = richHeader.pprint_header(richH)
        except:
            richStatus = "DanS signature not found/Non-Microsoft linker"
        return (richStatus + ": " + checksum)


    def getOverlay(self):
        # Ref: https://github.com/secrary/SSMA/blob/master/src/check_file.py

        overlayOffset = self.getPEFile().get_overlay_data_start_offset()
        raw = self.getPEFile().write()

        def NumberOfBytesHumanRepresentation(value):
            if value <= 1024:
                return '%s bytes' % value
            elif value < 1024 * 1024:
                return '%.1f KB' % (float(value) / 1024.0)
            elif value < 1024 * 1024 * 1024:
                return '%.1f MB' % (float(value) / 1024.0 / 1024.0)
            else:
                return '%.1f GB' % (float(value) / 1024.0 / 1024.0 / 1024.0)

        def CIC(expression):
            if callable(expression):
                return expression()
            else:
                return expression

        def IFF(expression, valueTrue, valueFalse):
            if expression:
                return CIC(valueTrue)
            else:
                return CIC(valueFalse)

        if overlayOffset == None:
            overlayStatus = "No overlay Data Present"
        else:
            overlayStatus = "Overlay Data is present"
            # print(' Start offset: 0x%08x' % overlayOffset)
            overlaySize = len(raw[overlayOffset:])
            # print(' Size:         0x%08x %s %.2f%%' % (overlaySize, NumberOfBytesHumanRepresentation(overlaySize), float(overlaySize) / float(len(raw)) * 100.0))
            # print(' MD5:          %s' % hashlib.md5(raw[overlayOffset:]).hexdigest())
            # print(' SHA-256:      %s' % hashlib.sha256(raw[overlayOffset:]).hexdigest())
            overlayMagic = raw[overlayOffset:][:4]
            """ 
            if type(overlayMagic[0]) == int:
                overlayMagic = ''.join([chr(b) for b in overlayMagic])
                print(' MAGIC:        %s %s' % (binascii.b2a_hex(overlayMagic), ''.join([IFF(ord(b) >= 32, b, '.') for b in overlayMagic])))
                print(' PE file without overlay:')
                print('  MD5:          %s' % hashlib.md5(raw[:overlayOffset]).hexdigest())
                print('  SHA-256:      %s' % hashlib.sha256(raw[:overlayOffset]).hexdigest())
            """
        return overlayStatus


    def getFileSignature(self):
        """ Problem with win32api could not install
        StringFileInfo (Rozena)
        ---------------
        CompanyName: Reilly INC.\00
        FileDescription: Lorem ipsum dolor sit amet, consecteteur adipiscing elit.\00
        InternalName: XHVLGR11DR\00
        OriginalFilename: Lista_Gerencia32\00
        """
        # print("VS_FIXEDFILEINFO")
        try:
            signature = ""
            for structure in self.getPEFile().VS_FIXEDFILEINFO:
                signature = hex(structure.Signature)
                # print("File OS: " + hex(structure.FileOS))

            # for fileVer in getPEFile(malware_path).VS_VERSIONINFO:
            # print(fileVer)
            """ 
            for fileInfo in getPEFile(malware_path).FileInfo:
                if 'StringFileInfo' in fileInfo:
                    for st_entry in fileInfo.StringTable:
                        for key, entry in list(st_entry.entries.items()):
                            print({key.decode(): entry.decode()})
            """
        except:
            signature = "No File signature extract"
        return signature


    def getMetadata(self):
        # ref: https://hachoir.readthedocs.io/en/latest/developer.html
        # Creation date, comment, format version, mime type, and endianness
        config.quiet = True
        parser = createParser(self.malware_path)
        metadataList = {}
        metadata = extractMetadata(parser)
        if metadata:
            try:
                for data in metadata:
                    if not data.values:
                        continue
                    key = data.description
                    value = ', '.join([item.text.strip() for item in data.values])
                    metadataList[key] = value
                if metadataList:
                    return metadataList
                else:
                    return "N/A"
            except:
                pass
        else:
            pass

    def getExifExecutable(self):
        exifInfo = {}
        with exiftool.ExifTool() as et:
            exifInfo.update(et.get_metadata(self.malware_path))
        return exifInfo
  
    def getFileDescription(self):
        try:
            fileDesc = self.getExifExecutable()['EXE:FileDescription']
            return fileDesc
        except:
            return None

    def getCompName(self):
        try:
            compName = self.getExifExecutable()['EXE:CompanyName']
            return compName
        except:
            return None

    def getInternalName(self):
        try:
            intName = self.getExifExecutable()['EXE:InternalName']
            return intName
        except:
            return None

    def getProductName(self):
        try:
            prodName = self.getExifExecutable()['EXE:ProductName']
            return prodName
        except:
            return None

    def getOriginalName(self):
        try:
            orgiName= self.getExifExecutable()['EXE:OriginalFileName']
            return orgiName
        except:
            return None

    def getFilePermission(self):
        try:
            permission = self.getExifExecutable()['File:FilePermissions']
            return permission
        except:
            return None

    def getLinkerVersion(self):
        try:
            linkV = self.getExifExecutable()['EXE:LinkerVersion']
            return linkV
        except:
            return None

    def getOSVersion(self):
        try:
            osV = self.getExifExecutable()['EXE:OSVersion']
            return osV
        except:
            return None

    def getEXETimestamp(self):
        try:
            ts = self.getExifExecutable()['EXE:TimeStamp']
            return ts
        except:
            return None

    def getEXEMIME(self):
        try:
            mime = self.getExifExecutable()['File:MIMEType']
            return mime
        except:
            return None

    def getEXESubsystem(self):
        try:
            subsys = self.getExifExecutable()['EXE:Subsystem']
            return subsys
        except:
            return None

    def getFileModification(self):
        try:
            fileMo = self.getExifExecutable()['File:FileModifyDate']
            return fileMo
        except:
            return None

    def get_antivm(self):
        result = {}
        # Credit: Joxean Koret
        VM_Sign = {
            "VMware trick": b"VMXh",
            "Xen": b"XenVMM",
            "Red Pill": b"\x0f\x01\x0d\x00\x00\x00\x00\xc3",
            "VirtualPc trick": b"\x0f\x3f\x07\x0b",
            "VMCheck.dll": b"\x45\xC7\x00\x01",
            "VMCheck.dll for VirtualPC": b"\x0f\x3f\x07\x0b\xc7\x45\xfc\xff\xff\xff\xff",
            "Bochs & QEmu CPUID Trick": b"\x44\x4d\x41\x63",
            "Torpig VMM Trick": b"\xE8\xED\xFF\xFF\xFF\x25\x00\x00\x00\xFF\x33\xC9\x3D\x00\x00\x00\x80\x0F\x95\xC1\x8B\xC1\xC3",
            "Torpig (UPX) VMM Trick": b"\x51\x51\x0F\x01\x27\x00\xC1\xFB\xB5\xD5\x35\x02\xE2\xC3\xD1\x66\x25\x32\xBD\x83\x7F\xB7\x4E\x3D\x06\x80\x0F\x95\xC1\x8B\xC1\xC3",
            "vmware": [b"sbiedll.dll", b"dbghelp.dll", b"wpespy.dll"],
            "SunBelt SandBox": [b"api_log.dll", b"dir_watch.dll",b"pstorec.dll"],
            "mac_addresses": [b"\x00\x3A\x1C\x3A\x14", b"\x00\x3A\x50\x3A\x56", b"\x00\x3A\x05\x3A\x69", b"\x00\x3A\x0C\x3A\x29", b"\x00\x3A\x03\x3A\xFF", b"\x08\x3A\x00\x3A\x27"]
        }

        with open(self.malware_path, "rb") as f:
            binfile = f.read()
        try:
            for trick in VM_Sign.keys():
                pos = buf.find(VM_Sign[trick])
                if pos > -1:
                    result.update({"VM": trick, "offset": hex(pos)})
                else:
                    result.update({"VM": "No VM Detection"})
            return result
        except:
            return "N/A"

    def get_xor(self, search_string=False):
        xorsearch_custom = False
        offset_list = []
        search_file = open(self.malware_path, "rb").read()
        key_lengths = [1, 2, 4, 8]
        is_xored = False
        check = {}
        if not search_string:
            search_string = b"This program cannot be run in DOS mode."
        else:
            str(search_string)
            xorsearch_custom = True

        for l in key_lengths:
            key_delta = self.xor_delta(search_string, l)
            doc_delta = self.xor_delta(search_file, l)
            offset = -1
            while True:
                offset += 1
                offset = doc_delta.find(key_delta, offset)
                if (offset > 0) and offset not in offset_list:
                    offset_list.append(offset)
                    f = open(self.malware_path, 'rb')
                    f.seek(offset, 0)
                    data = f.read(39)
                    if search_string in data:
                        is_xored = True
                    try:
                        data = str(data.decode("utf-8"))
                    except:
                        data = str(data)

                    check.update({hex(offset): data})
                else:
                    break

        if is_xored or xorsearch_custom:
            if len(list(check.keys())) == 1:
                return str(list(check.keys())[0])
            else:
                return list(check.keys())
        else:
            return None


    def xor_delta(self, s, key_len=1):
        delta = array.array('B', s)

        for x in range(key_len, len(s)):
            delta[x - key_len] ^= delta[x]

        """ return the delta as a string """
        return delta.tobytes()[:-key_len]

        # XOR decryption
        # def xor_mb(message, key):
        # return ''.join(chr(ord(m_byte) ^ ord(k_byte)) for m_byte, k_byte in zip(message, cycle(key)))


    def path_to_file(self, filename, folder):
        _ROOT = os.path.abspath(os.path.dirname(__file__))
        return os.path.join(_ROOT, folder, filename)


    def load_config(self, config_file):
        with open(config_file) as conf:
            data = json.load(conf)
        return data

        # ref mutex namelist: http://hexacorn.com/examples/2014-12-24_santas_bag_of_mutants.txt
        # http://hexacorn.com/examples/2015-04-05_easter_bunny_with_a_bag_full_of_events.txt

    def getCrypto(self):
        # import plyara
        # Represent yara rule in dictionary format
        # parser = plyara.Plyara()
        # rules_list = parser.parse_string(
        # open('/Users/koyko/PycharmProjects/Malware/signatures/yara_plugins/pe/crypto_signatures.yar').read())
        # with open("/Users/koyko/Desktop/GandCrabv4.exe", "rb") as fR:
        # bytestring = fR.read().hex()
        # bytestring = " ".join([bytestring[i:i+2] for i in range(0, len(bytestring), 2)])

        rules = yara.compile('crypto_signatures.yar')
        matches = rules.match(data=open(self.malware_path, "rb").read())
        # print("Match Yara Rule: " + str(matches))
        if matches:
            for match in matches:
                if "BASE64" in match:
                    result = "BASE64"
                elif "AES" in match:
                    result = "AES"
                elif "CRC32" in match:
                    result = "CRC32"
                elif "Crypt32" in match:
                    result = "Crypt32 Library"
                else:
                    result = "Unspecified"
            return result
        else:
            return None
        # from modules import yara_check

        # print("Trigger Yara Rule: " + str(yara_check.yara_match_from_file(
        # path_to_file('crypto_signatures.yar', '/Users/koyko/PycharmProjects/Malware/signatures/yara_plugins/pe'),
        # malware_path)))

        # ref: https://github.com/Yara-Rules/rules
        # ref: https://www.programcreek.com/python/example/104960/yara.compile
        # ref: https://www.securitysift.com/pecloak-py-an-experiment-in-av-evasion/


    def getObfuscation(self):
        # ref: https://github.com/Maratyszcza/PeachPy
        # ref: https://github.com/Aurore54F/JaSt
        # ref: https://www.capstone-engine.org/lang_python.html
        entrypoint = self.getPEFile().OPTIONAL_HEADER.AddressOfEntryPoint
        binary_code = self.getPEFile().get_memory_mapped_image()[entrypoint:entrypoint + 2000]
        # initiate disassembler to disassemble 32bit x86
        disasm = []
        mode = CS_MODE_32
        statusObfus = ""
        if self.getPEFile().OPTIONAL_HEADER.Magic == 0x20b:
            mode = CS_MODE_64
        disassembler = Cs(CS_ARCH_X86, mode)

        # disassemble the code
        for instruction in disassembler.disasm(binary_code, entrypoint):
            if instruction.mnemonic != "int3" and instruction.mnemonic == "mov":
                if "ptr [ebp" in instruction.op_str or "prt [rbp" in instruction.op_str:
                    # print("0x%x:\t%s\t\t%s" % (instruction.address, instruction.mnemonic, instruction.op_str))
                    disasm.append(hex(instruction.address) + " " + instruction.mnemonic + " " + instruction.op_str)
            if instruction.mnemonic == "rdtsc" or instruction.mnemonic == "cpuid":
                #instruction returns the count of the number of ticks since the last system reboot as a 64-bit value placed into EDX:EAX. Simply execute this instruction twice and compare the difference between the two readings
                disasm.append("Timing Checks")
        if not disasm:
            statusObfus = "Obfuscation may be not implemented"
        else:
            if "Timing Checks" in disasm:
                statusObfus = "Obfuscation is implemented, Time checks"
            else:
                statusObfus = "Obfuscation is implemented"
        return statusObfus
        #
        # ref: https://github.com/carbonblack/tic/tree/master/mpesm
        # print("Packer are: " + str(mpesm.get_result(malware_file,load_config(path_to_file('stringsmatch.json',
        #                                                                                '/Users/koyko/PycharmProjects/Malware/signatures'))[
        #                                                           'mnemonics'].values(),disasm)))


    def getExecFileType(self):  # identify file extension for binaries
        fileType = ""
        try:
            if self.getPEFile().DOS_HEADER.e_magic == 0x5a4d and self.getPEFile().NT_HEADERS.Signature == 0x4550:
                if self.getPEFile().is_driver():
                    fileType = "Driver file (.sys)"
                elif self.getPEFile().is_exe():
                    fileType = "Executable file (.exe)"
                elif self.getPEFile().is_dll():
                    fileType = "DLL file (.dll)"
                else:
                    fileType = "N/A"
        except ValueError:
            fileType = "Input file should be executable (PE format: exe or dll)"
        return fileType


    def C2BIP3(self, string):
        if sys.version_info[0] > 2:
            return bytes([ord(x) for x in string])
        else:
            return string


    from time import time


    def getZipFileType(self):
        return subprocess.Popen(["7z", "x", "-pinfected", self.malware_path, "-o/content/gdrive/My Drive/Zip_Malware"], stdout=subprocess.PIPE, universal_newlines=True)

    def getPDFFile(self):
        # ref: http://www.blog.pythonlibrary.org/2018/05/03/exporting-data-from-pdfs-with-python/
        # ref: https://www.programcreek.com/python/example/93549/pdfminer.pdfparser.PDFParser
        # ref: https://zeltser.com/analyzing-malicious-documents/
        # ref: https://blog.didierstevens.com/2008/05/19/pdf-stream-objects/
        # Set parameters for analysis.
        file_object = pdfrw.PdfReader(self.malware_path)
        pdfInfo = {}
        try:
            print(file_object.Root.keys())  # '/Type', '/Outlines', '/Pages', '/Names', '/OpenAction'
            print(len(file_object.pages))  # number of pages
            print(file_object.Info)
            pdfFileObj = open(self.malware_path, 'rb')
            pdfReader = PyPDF2.PdfFileReader(pdfFileObj)
            """
            xmpm = pdfReader.getXmpMetadata()
            if xmpm is None:
                print("No XMP metadata found in document.")
                sys.exit()
            if xmpm.custom_properties:
                print("Custom Properties:")
                for k, v in xmpm.custom_properties.items():
                    print("\t{}: {}".format(k, v))

            def custom_print(fmt_str, value):
                if isinstance(value, list):
                    print(fmt_str.format(", ".join(value)))
                elif isinstance(value, dict):
                    fmt_value = [":".join((k, v)) for k, v in value.items()]
                    print(fmt_str.format(", ".join(value)))
                elif isinstance(value, str) or isinstance(value, bool):
                    print(fmt_str.format(value))
                elif isinstance(value, bytes):
                    print(fmt_str.format(value.decode()))
                elif isinstance(value, datetime.datetime):
                    print(fmt_str.format(value.isoformat()))
                elif value is None:
                    print(fmt_str.format("N/A"))
                else:
                    print("warn: unhandled type {} found".format(type(value)))

            custom_print("Title: {}", xmpm.dc_title)
            custom_print("Creator(s): {}", xmpm.dc_creator)
            custom_print("Contributors: {}", xmpm.dc_contributor)
            custom_print("Subject: {}", xmpm.dc_subject)
            custom_print("Description: {}", xmpm.dc_description)
            custom_print("Created: {}", xmpm.xmp_createDate)
            custom_print("Modified: {}", xmpm.xmp_modifyDate)
            custom_print("Event Dates: {}", xmpm.dc_date)
            custom_print("Created With: {}", xmpm.xmp_creatorTool)
            custom_print("Document ID: {}", xmpm.xmpmm_documentId)
            custom_print("Instance ID: {}", xmpm.xmpmm_instanceId)
            custom_print("Language: {}", xmpm.dc_language)
            custom_print("Publisher: {}", xmpm.dc_publisher)
            custom_print("Resource Type: {}", xmpm.dc_format)
            custom_print("Type: {}", xmpm.dc_type)
            """

            objectStream = ['/OpenAction', '/AA', '/JavaScript', '/JS', '/GoTo', '/URI', '/Launch', '/SubmitForm', '/GoToR',
                            '/RichMedia', '/ObjStm']
            if pdfReader.isEncrypted:
                pdfReader.decrypt('password')

            try:
                pdfDocInfo = {pdfReader.getDocumentInfo()}
            except:
                pdfDocInfo = None

            parser = PDFParser(pdfFileObj)
            document = PDFDocument(parser)
            # Check if the document allows text extraction. If not, abort.
            if not document.is_extractable:
                raise PDFTextExtractionNotAllowed

            resource_manager = PDFResourceManager()
            fake_file_handle = io.StringIO()
            converter = TextConverter(resource_manager, fake_file_handle)
            page_interpreter = PDFPageInterpreter(resource_manager, converter)
            with open(self.malware_path, 'rb') as fh:

                for page in PDFPage.get_pages(fh, caching=True, check_extractable=True):
                    page_interpreter.process_page(page)

                text = fake_file_handle.getvalue()
            converter.close()
            fake_file_handle.close()

            re_printable_string = re.compile(b'[\\t\\r\\n\\x20-\\xFE]{5,}')
            if file_object.pages[
                0].Contents.stream:  # BT /F1 12 Tf 70 700 Td 15 TL (PDF file containing DOC file with VBA EICAR dropper. Created by Didier Stevens.) Tj ET
                pdfContent = "Suspicious content"
            else:
                pdfContent = None

            for objID in range(1, 20):
                if objID == 1:
                    for objID1K, objID1V in document.catalog.items():
                        if 'OpenAction' in objID1K or 'Javascript' in objID1K or 'EmbeddedFiles' in str(objID1V):
                            pdfStream = "Suspicious Catalog"
                streamC = str(document.getobj(objID))
                if streamC.startswith("<PDFStream") and 'Filter' in streamC:
                    # print("StreamID: " + str(objID) + ": " + streamC)
                    streamByte = document.getobj(objID).get_data()
                    if b'\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1' in streamByte:  # ole format
                        streamHex = bytes.hex(streamByte)
                        """  Stream Filter specify what compression/encoding applied to original data before included in stream
                                        ASCIIHexDecode
                                        ASCII85Decode
                                        LZWDecode
                                        FlateDecode
                                        RunLengthDecode
                                        CCITTFaxDecode
                                        JBIG2Decode
                                        DCTDecode
                                        JPXDecode
                                        Crypt
                        """
                        # print(hexdump.hexdump(document.getobj(objID).get_data()))
                        # hex_bytes = " ".join(['{:02X}'.format(byte) for byte in streamByte])
                        with open('/Users/koyko/Documents/myfile.doc', 'wb') as w:
                            w.write(bytes.fromhex(streamHex))
                        self.check_fileWord('/Users/koyko/Documents/myfile.doc')
                    else:
                        continue
                elif 'Action' in streamC or 'Javascript' in streamC or 'JS' in streamC:
                    print("StreamID: " + str(objID) + ": " + streamC)

            pdfFileObj.close()
        except:
            return None

        # compression used is the Flate method of the zlib library. You can see this because of the /Filter /FlateDecode entry. In the PDF parlance, a filter is a compression method. A stream of data can be compressed by more than one filter.

        return {"pdfDocumentInfo": pdfDocInfo, "pdfContent": pdfContent, "pdfStream": pdfStream}

    def check_fileWord(self):
        # ref: https://pillow.readthedocs.io/en/3.1.x/reference/OleFileIO.html
        # ref: https://github.com/decalage2/oletools/wiki/olevba
        # ref for ooxml: https://github.com/grierforensics/officedissector
        # olefile.MAGIC = '\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1'
        # olefile.STGTY_STREAM = 2, olefile.STGTY_STORAGE = 1
        if zipfile.is_zipfile(self.malware_path):
            zfile = zipfile.ZipFile(self.malware_path)
            core_xml = etree.fromstring(zfile.read('docProps/core.xml'))
            app_xml = etree.fromstring(zfile.read('docProps/app.xml'))
            core_mapping = {
                'title': 'Title',
                'subject': 'Subject',
                'creator': 'Author(s)',
                'keywords': 'Keywords',
                'description': 'Description',
                'lastModifiedBy': 'Last Modified By',
                'modified': 'Modified Date',
                'created': 'Created Date',
                'category': 'Category',
                'contentStatus': 'Status',
                'revision': 'Revision'
            }
            for element in core_xml.getchildren():
                for key, title in core_mapping.items():
                    if key in element.tag:
                        if 'date' in title.lower():
                            text = datetime.datetime.strptime(element.text, "%Y-%m-%dT%H:%M:%SZ")
                        else:
                            text = element.text
                        print("{}: {}".format(title, text))
            app_mapping = {
                'TotalTime': 'Edit Time (minutes)',
                'Pages': 'Page Count',
                'Words': 'Word Count',
                'Characters': 'Character Count',
                'Lines': 'Line Count',
                'Paragraphs': 'Paragraph Count',
                'Company': 'Company',
                'HyperlinkBase': 'Hyperlink Base',
                'Slides': 'Slide count',
                'Notes': 'Note Count',
                'HiddenSlides': 'Hidden Slide Count',
            }
            for element in app_xml.getchildren():
                for key, title in app_mapping.items():
                    if key in element.tag:
                        if 'date' in title.lower():
                            text = datetime.datetime.strptime(element.text, "%Y-%m-%dT%H:%M:%SZ")
                        else:
                            text = element.text
                        print("{}: {}".format(title, text))
        else:
            print("Word filename analysis is: " + str(macro.get_result(self.malware_path)))
            # regex to extract printable strings (at least 5 chars) from VBA Forms:
            # (must be bytes for Python 3)
            re_printable_string = re.compile(b'[\\t\\r\\n\\x20-\\xFF]{5,}')
            vbaparser = olevba.VBA_Parser(self.malware_path)
            if olefile.isOleFile(self.malware_path):
                with olefile.OleFileIO(self.malware_path, raise_defects=olefile.DEFECT_INCORRECT) as wordFile:
                    if wordFile.parsing_issues:
                        for exctype, msg in wordFile.parsing_issues:
                            print('- %s: %s' % (exctype.__name__, msg))
                    else:
                        print(
                            wordFile.listdir())  # a list of all the streams contained in the OLE file, including those stored in storages
                    if vbaparser.detect_vba_macros():
                        print("This document seems to contain VBA macros.")
                    try:
                        sizeStream = wordFile.get_size('WordDocument')  # the size of a stream in byte
                        typeStream = wordFile.get_type(
                            'WordDocument')  # type of a stream/storage, STGTY\_STREAM for a stream, STGTY\_STORAGE for a storage, STGTY\_ROOT for the root entry, and False for a non existing path

                        createTime = wordFile.getctime(
                            'WordDocument')  # creation and modification timestamps of a stream/storage
                        modifyTime = wordFile.getmtime('WordDocument')

                    except:
                        print("OLE file did not store timestamp")
                    if wordFile.exists("macros/vba"):
                        print("This document seems to contain VBA macros.")
                    meta = wordFile.get_metadata()
                    print('Author:', meta.author)
                    print('Title:', meta.title)
                    print('Creation date:', meta.create_time)
                    # print all metadata:
                    meta.dump()
                    print(wordFile.dumpdirectory())  # expected (for debugging only)
                    print(str(sizeStream) + "\t" + str(typeStream))
                    pics = wordFile.openstream('Macros/VBA/DWNdEzf')
                    data = pics.read()
                    # olevba.detect_base64_strings(vba_code)
                    print("DWNdEzf:" + bytes.hex(data))  # hex
                    pic1 = wordFile.openstream('Macros/VBA/nkdK49Zq')  # nkdK49Zq
                    # str_list = re.findall("[^\x00-\x1F\x7F-\xFF]{4,}", str(pic1.read()))
                    # olevba.decompress_stream(compressed_container=)

            else:
                print("Not")

            for (filename, stream_path, vba_filename, vba_code) in vbaparser.extract_macros():
                print('-' * 79)
                print('Filename    :', filename)
                print('OLE stream  :', stream_path)
                print('VBA filename:', vba_filename)
                print('- ' * 39)
                print(vba_code)
            # print(vbaparser.extract_all_macros())
            result = vbaparser.analyze_macros()
            for kw_type, keyword, description in result:
                print('type=%s - keyword=%s - description=%s' % (kw_type, keyword, description))

            vbaparser.close()
            # Use vipermonkey to deobfuscate vba macros
            #vmonkey_output = open('/Users/koyko/Desktop/vmonkey_result.txt', 'w+')
            #process = subprocess.run(['vmonkey', self.malware_path], stdout=vmonkey_output, stderr=subprocess.PIPE, universal_newlines=True)


    EXCEL_FILE_EXTENSIONS = ('xlsb', 'xls', 'xlsm', 'xla', 'xlt', 'xlam',)


    def parseExcel(workbook_path):
        vba_path = workbook_path + '.vba'
        vba_parser = olevba.VBA_Parser(workbook_path)
        vba_modules = vba_parser.extract_all_macros() if vba_parser.detect_vba_macros() else []

        for _, _, _, content in vba_modules:
            decoded_content = content.decode('latin-1')
            lines = []
            if '\r\n' in decoded_content:
                lines = decoded_content.split('\r\n')
            else:
                lines = decoded_content.split('\n')
            if lines:
                name = lines[0].replace('Attribute VB_Name = ', '').strip('"')
                content = [line for line in lines[1:] if not (
                        line.startswith('Attribute') and 'VB_' in line)]
                if content and content[-1] == '':
                    content.pop(len(content) - 1)
                    lines_of_code = len(content)
                    non_empty_lines_of_code = len([c for c in content if c])
                    if non_empty_lines_of_code > 0:
                        if not os.path.exists(os.path.join(vba_path)):
                            os.makedirs(vba_path)
                        with open(os.path.join(vba_path, name + '.bas'), 'w') as f:
                            f.write('\n'.join(content))

    def getFileName(self):
        try:
            return self.malware_path.split("/")[-1]
        except:
            return "N/A"

    def getArchType(self):
        if self.getPEFile().FILE_HEADER.Machine == 0x014c:
            arch = "32-bit Application"
        elif self.getPEFile().FILE_HEADER.Machine == 0x8664:
            arch = "64-bit Application"
        else:
            arch = "Itanium Application"  # 0x0200
        return arch

    def getMIMEType(self):
        try:
            mimeGuess = mimetypes.guess_type(self.malware_path.split("/")[-1])[0]
        except:
            mimeGuess = "N/A"
        return mimeGuess

    def getCreationDate(self):
        try:
            createDate = self.getMetadata()['Creation date']
            if createDate:
                return createDate
            else:
                return "N/A"
        except:
            return None

    def getFormatVersion(self):
        try:
            formatVersion = self.getMetadata()['Format version']
            if formatVersion:
                return formatVersion
            else:
                return "N/A"
        except:
            return None

    def getMIME(self):
        try:
            mimeT = self.getMetadata()['MIME type']
            if mimeT:
                return mimeT
            else:
                return "N/A"
        except:
            return None

    def get_result(strings_match):
        alerts = []
        try:
            for entry in pefile.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                  func = imp.name.decode('utf-8')
                  for alert in strings_match:
                    if alert and func != None: # remove 'null'
                      if func.startswith(alert):
                        alerts.append(func)
            if len(alerts) == 1:
                return str(alerts[0])
            elif not alerts:
                return "N/A"
            else:
                return sorted(set(alerts))
            print(alerts)
        except:
            return None

    def getSHA256(self):
        h = hashlib.sha256()
        with open(self.malware_path, 'rb') as file:
            while True:
                # Reading is buffered, so we can read smaller chunks.
                chunk = file.read(h.block_size)
                if not chunk:
                    break
                h.update(chunk)
        print(h.hexdigest())
        return h.hexdigest()
            
    def get_BinaryResult(self):
        self.featureStatic = {}
        try:
            #csvWriter = csv.writer(csvfile, delimiter=",", quoting=csv.QUOTE_ALL, quotechar="'")
            self.featureStatic.update({"FileName": self.getFileName(), "Type of File": self.getExecFileType(),
                                           "Architecture": self.getArchType(),
                                           "Application Type": self.getMIMEType(),
                                           "MIME type": self.getEXEMIME(),
                                           "ImageBase": self.getImageBase(),
                                   "Size of Initialize Data": self.getInitializedData(),
                                   "Size of Code": self.getCodeSize(),
                                   "File size": self.getFileSize(),
                                   "Sum of Raw Data": self.getSumOfRawData(),
                                   "Number of Sections": self.getNumberSections(),
                                   "Imphash": self.getImphash(),
                                   "Imports": self.getImportedList(),
                                   "Imported DLLs": self.getDllList(),
                                   "Suspicious Imported": self.getSuspiciousImportedEntries(),
                                   "mscoree.dll": self.getMSCOREE(),
                                   "kernel32.dll": self.getKernelDll(),
                                   "msvcr110.dll": self.getMSVCR110(),
                                   "msvcr80.dll": self.getMSVCR80(),
                                   "ntdll.dll": self.getNTDll(),
                                   "ataport.sys": self.getATAPORT(),
                                   "msvcp90.dll": self.getMSVCP90(), "winmm.dll": self.getWINMM(),
                                   "gdi32.dll": self.getGDI32(),
                                   "ntoskrnl.exe": self.getNTOSKRNL(), "ws2_32.dll": self.getWS232(),
                                   "msvcrt.dll": self.getMSVCRT(),
                                   "setupapi.dll": self.getSetupAPI(),
                                   "comctl32.dll": self.getCompCTL(),
                                   "user32.dll": self.getUser32(),
                                   "psapi.dll": self.getPSAPI(),
                                   "oleaut32.dll": self.getOLEAUT(), "version.dll": self.getVersionDll(),
                                   "advapi32.dll": self.getADVAPI(), "rpcrt4.dll": self.getRPCRT(),
                                   "shell32.dll": self.getSHELL32(),
                                   "wininet.dll": self.getWinInet(), "usbport.sys": self.getUSBPort(),
                                   "hal.dll": self.getHAL(), "msvcm80.dll": self.getMSVCM80(),
                                   "msvcm90.dll": self.getMSVCM90(), "crypt32.dll": self.getCrypt32(),
                                   "wintrust.dll": self.getWinTrust(), "comdlg32.dll": self.getCOMDLG32(),
                                   "userenv.dll": self.getUserEnv(), "shlwapi.dll": self.getSHLWAPI(),
                                   "dnsapi.dll": self.getDNSAPI(), "secur32.dll": self.getSecur32(),
                                   "winspool.drv": self.getWinSpool(), "ole32.dll": self.getOLE32(),
                                   "msvcr90.dll": self.getMSVCR90(), "iphlpapi.dll": self.getIPHL(),
                                   "msvcp80.dll": self.getMSVCP80(), "oleacc.dll": self.getOLEACC(),
                                   "wmilib.sys": self.getWMILIB(), "urlmon.dll": self.getUrlMon(),
                                   "gdiplus.dll": self.getGDIPlus(),
                                   "Others DLL": self.getOthersDll(),
                                   "Exported DLLs": self.getExportedList(),
                                   "Debug Directory": self.getDebugDir(),
                                   "PDBInfo": self.getPDBInfo(),
                                   "App Manifest": self.getManifest(),
                                   "Rich Header": self.getRichHeader(),
                                   "Overlay": self.getOverlay(),
                                   "File Signature": self.getFileSignature(),
                                   "Creation Date": self.getCreationDate(),
                                   "EXE TimeStamp": self.getEXETimestamp(),
                                   "Format version": self.getFormatVersion(),
                                   "Mutex api": str(
                                       apialert.get_result(self.getPEFile(),
                                                           self.load_config('stringsmatch.json')[
                                                               'mutex'])),
                                   "Antidbg": str(apialert.get_result(self.getPEFile(), self.load_config('stringsmatch.json',)[
                                       'antidbg'])),
                                   "Antivm": self.get_antivm(),
                                   "XOR": self.get_xor(),
                                   "Packer": self.getPacker(),
                                   "Entropy": self.getMaxEntropy(),
                                   "Obfuscation": self.getObfuscation(),
                                   "Exif Image Data": self.getHiddenFiles(),
                                   "Icon file": self.getIconFiles(),
                                   "OS Version": self.getOSVersion(),
                                   "Linker Version": self.getLinkerVersion(),
                                   "File Description": self.getFileDescription(),
                                   "Company Name": self.getCompName(),
                                   "Internal Name": self.getInternalName(),
                                   "Product Name": self.getProductName(),
                                   "Original Filename": self.getOriginalName(),
                                   "File Permissions": self.getFilePermission(),
                                   "SubSystem": self.getEXESubsystem(),
                                   "File Modification": self.getFileModification(),
                                   "SHA256": self.getSHA256()})
            return self.featureStatic
        except:
            pass

    def write_staticoutput(self):
        staticF = self.get_BinaryResult()
        print(staticF)
        df = pd.DataFrame.from_dict([staticF])
        df.to_csv("static_New2.csv", header=False, index=False, mode="a")

    def getOtherBinaries(self):
        with open(self.malware_path, "rb") as exe_file:
            line = exe_file.read().decode('ISO-8859-1')
            if line[0:2] == "MZ":
                self.get_BinaryResult()
            else:
                pass

def main():
    header = ["FileName", "Type of File", "Architecture", "Application Type", "MIME type", "ImageBase",
              "Size of Initialize Data", "Size of Code", "File size", "Sum of Raw Data", "Number of Sections",
              "Imphash", "Imports",
              "Imported DLLs", "Suspicious Imported", "mscoree.dll", "kernel32.dll", "msvcr110.dll", "msvcr80.dll",
              "ntdll.dll", "ataport.sys", "msvcp90.dll", "winmm.dll", "gdi32.dll", "ntoskrnl.exe", \
              "ws2_32.dll", "msvcrt.dll", "setupapi.dll", "comctl32.dll", "user32.dll", "psapi.dll", "oleaut32.dll",
              "version.dll", \
              "advapi32.dll", "rpcrt4.dll", "shell32.dll", "wininet.dll", "usbport.sys", "hal.dll", "msvcm80.dll",
              "msvcm90.dll", "crypt32.dll", \
              "wintrust.dll", "comdlg32.dll", "userenv.dll", "shlwapi.dll", "dnsapi.dll", "secur32.dll",
              "winspool.drv", "ole32.dll", \
              "msvcr90.dll", "iphlpapi.dll", "msvcp80.dll", "oleacc.dll", "wmilib.sys", "urlmon.dll", "gdiplus.dll",
              "Others DLL", "Exported DLLs", "Debug Directory", "PDBInfo", "App Manifest",
              "Rich Header", "Overlay", "File Signature", "Creation Date", "EXE TimeStamp", "Format version", "Mutex api", "Antidbg", "Antivm",
              "XOR", "Packer", "Entropy","Obfuscation", "Exif Image Data", "Icon file", "OS Version", "Linker Version",
              "File Description", "Company Name", "Internal Name", "Product Name", "Original Filename",
              "File Permissions", "SubSystem","File Modification","SHA256", "Label"]
    with open("static_New2.csv", "w") as f:
        csvWriter2 = csv.DictWriter(f,
                                    fieldnames=header)
        csvWriter2.writeheader()
    for root, dirs, files in os.walk("/content/gdrive/My Drive/NNN1"):
        for file1 in sorted(files, key=lambda x: str(x.split(".")[0])):
            try:
                guessExt = subprocess.Popen(["file", os.path.join(root, file1)], stderr=subprocess.PIPE, stdout=subprocess.PIPE)
                out, err = guessExt.communicate()
                malB = os.path.join(root, file1)
                testStatic = PEAnalysis(malB)
                if file1.endswith(".doc") or file1.endswith(".docx"):
                    testStatic.check_fileWord()
                elif file1.endswith(".exe") or file1.endswith(".bin") or b"PE32" in out or b"Windows" in out:
                    print("Executable Filename: " + file1)
                    testStatic.write_staticoutput()
                    #multiprocessing.Process(target=testStatic.write_staticoutput()).start()
                elif file1.endswith(".zip"):
                    testStatic.getZipFileType()
                elif file1.endswith(".pdf"):
                    testStatic.getPDFFile()
                elif file1.endswith(".js"):
                    print("Javascript filename analysis is: " + file1)
                    # elif file.endswith(EXCEL_FILE_EXTENSIONS):
                    # malEx = parseExcel(os.path.join(r, file))
                else:
                    testStatic.getOtherBinaries()
            except:
                pass
    for root, dirs, files in os.walk("/content/gdrive/My Drive/Zip_Malware"):
        for file in sorted(files, key=lambda x: str(x.split(".")[0])):
            guessExt = subprocess.Popen(["file", os.path.join(root, file1)], stderr=subprocess.PIPE, stdout=subprocess.PIPE)
            out, err = guessExt.communicate()
            if file.endswith(".exe") or file.endswith(".bin") or b"PE32" in out:
                malZ = os.path.join(root, file)
                testStatic = PEAnalysis(malZ)
                #multiprocessing.Process(target=testStatic.write_staticoutput()).start()
            else:
                pass

if __name__ == '__main__':
    main()
